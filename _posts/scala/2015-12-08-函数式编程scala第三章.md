---
layout: post
title: 函数式编程scala第三章
description: 
category: scala
---

函数式数据结构v2
====


3.1介绍
----

我们在介绍中说，函数式程序不会更新变量或修改数据结构。这就提出了一个紧迫的问题------什么样的数据结构*可以*用在函数式编程中，我们如何在Scala中定义它们，我们如何操作这些数据结构？在本章中，我们将学习*函数式数据结构*的概念，和如何定义和使用这种数据结构。我们将以此为契机，介绍如何在函数式编程中定义数据类型，了解*模式匹配*的相关技术，亲自编写和归纳纯函数。

本章有大量的练习，特别是为最后一点提供帮助------编写和归纳纯函数。一些练习可能极具挑战。一如既往，如果你需要的话，请咨询一下提示或答案，或者线上寻求帮助。

3.2定义函数式数据结构
----

函数式的数据结构（别惊讶！）只使用纯函数操作。记住，一个纯函数可能只接受一些值作为输入，并产生一个值作为输出。它可不会改变数据或执行其他副作用。*因此，函数式数据结构是不可变的*。例如，空列表，（Scala中记作List()或Nil）像整数3或4一样是永恒不变的。正如对3 + 4求值的结果是一个新数字7，而并没有修改3或4一样，把两个List合并到一起（语法是：对于List a和b，a ++ b）产生一个新的List，但不改变两个输入的List。

这难道不意味着我们最终进行了大量数据的额外复制吗？令人颇为惊讶的答案是，“不”。在研究了链表（singly-linked list），这个也许是最无处不在的函数式数据结构之后，我们将再次回到这个问题。这里的定义在思想上（虽然简单点）和Scala标准库中定义的List数据类型一致。这个代码清单使用了很多新的语法和概念，如果不是所有的东西都能明白也不用担心，首先我们会详细讨论它[^footnote1]。

[^footnote1]:注意------sum和product方法的实现在这里没有使用尾递归。我们会在本章中完成它们的尾递归版本。

清单3.1 链表

	package fpinscala.datastructures
	
	sealed trait List[+A] //1
	case object Nil extends List[Nothing] //2
	case class Cons[+A](head: A, tail: List[A]) extends List[A]
	
	object List { //3
	  def sum(ints: List[Int]): Int = ints match { //4
	    case Nil => 0
	    case Cons(x,xs) => x + sum(xs)
	}
	
	  def product(ds: List[Double]): Double = ds match {
	    case Nil => 1.0
	    case Cons(0.0, _) => 0.0
	    case Cons(x,xs) => x * product(xs)
	}
	
	  def apply[A](as: A*): List[A] = //5
	    if (as.isEmpty) Nil
	    else Cons(as.head, apply(as.tail: _*))
	    
	  val example = Cons(1, Cons(2, Cons(3, Nil))) //6
	  val example2 = List(1,2,3)
	  val total = sum(example)
	}

 1. List数据类型
 2. List的构造函数
 3. List的伴生对象
 4. 模式匹配例子
 5. 可变参数函数的语法
 6. 创建一个List

让我们先来看看数据类型的定义，它以关键字sealed trait开始。在一般情况下，我们使用特质（trait）关键字引入一个数据类型。trait是一个抽象的接口，它可选择性的包含一些方法的具体实现。在这里，我们声明一个不包含方法的特质，List。在前面添加sealed意味着我们的特质必须在这个文件中声明所有的实现[^footnote2]。


[^footnote2]:我们也可以使用抽象类来替代特质。从技术上讲，一个抽象类可以包含构造函数，在面向对象的意义上，这用来区分它和特质，特质不能包含构造函数。这种区别和我们现在的目的没有关系。


声明了两种List的实现或称为*数据构造器*（data constructors）（每种实现都附带关键字case），代表两种可能的List的形式-------它可以是*空的*，由数据构造器Nil表示，也可以是非空的（数据构造器Cons，通常是"construct"的简称），在这种情况下，它由最初的元素，head，后面跟着一个List（可能为空）包含剩余的元素（tail）。

清单3.2 List的数据构造器

	case object Nil extends List[Nothing]
	case class Cons[+A](head: A, tail: List[A]) extends List[A]

正如函数可以是多态的，数据类型也可以，通过在sealed trait List之后添加类型参数[+A]，之后可以在Cons数据构造器中使用参数A，我们已经声明了List数据类型包含的元素是多态的，这意味着我们可以使用同一定义在Int（表示为List[Int]），Double（表示为List[Double]），String（标识为List[String]），等等。（+表示这个类型参数A是*协变*的------你可以侧边栏"关于型变的更多信息"中查询到）。

一个数据构造器给我们提供了一种构造数据类型的方式（case object Nil让我们用Nil来构造一个空的List，而case class Cons让我们用Cons(1, Nil)，Cons(1, Cons(2, Nil))，等形式来构造一个非空List），还介绍了一种模式，可以用于模式匹配，如同函数sum和product一样。

>侧边栏：关于型变的更多信息
>在声明trait List[+A]时，在类型参数前的+是一个*型变注解*，它表示A是List的*协变*或称之为"积极"的参数。这意味着假设Dog是Animal的子类，那么List[Dog]被认为是List[Animal]的子类。（一般情况下，对于任何类型X和Y，如果X是类型Y的子类，那么List[X]就是List[Y]的子类）。如果我们把在A前面的"+"去掉，这将使List的类型参数从协变变为*不变*。
>但请注意，Nil继承自List[Nothing]。Nothing是所有类型的子类，这就意味着加之型变注解，Nil可以被认为是List[Int]，List[Double]等，这正是我们想要的。
>在本章中型变并不太重要，更重要的是Scala通过子类进行数据构造，所以如果你现在并没有彻底搞清楚型变也不要担心[^footnote3]。

[^footnote3]:完全不使用型变注解来写代码当然是可行的，函数签名有时更简单（而类型推断往往会变得更糟）。除非另有说明，我们将在这本书中使用型变注释，但是你应该对这两种方法都自由的尝试。

3.2.1模式匹配
----

让我们看看函数sum和product的细节，这两个函数我们放在object List中，有时被称为List的*伴生对象*（见侧边栏）。这两种定义都使用了模式匹配。

	def sum(ints: List[Int]): Int = ints match {
	  case Nil => 0
	  case Cons(x,xs) => x + sum(xs)
	}
	
	def product(ds: List[Double]): Double = ds match {
	  case Nil => 1.0
	  case Cons(0.0, _) => 0.0
	  case Cons(x, xs) => x * product(xs)
	}


正如你可能期望的，sum函数表示空List的和为0，非空List的和是第一个元素x加上剩余的元素xs的和[^footnote4]，同样的，product函数表示一个空List的乘积为1，以0.0开始的List的乘积为0.0，[^footnote5]，非空List的乘积是第一个元素乘以剩余的元素的乘积。注意这两个函数都是递归定义的，这在编写函数处理像List一样（Cons数据构造器递归的引用了自身）的递归数据类型时很常见。

[^footnote4]:这里的x和xs我们可以用任何名称，但它是常见的惯例使用xs、ys、as、bs作为一个序列的变量名，x、y、z、a或b为一个序列中单一元素的变量名。另一种常见的命名规则是h表示List的第一个元素（List中的"头"），t表示其余的元素（"尾"），l表示一个完整的List。
[^footnote5]:LISTS



[^footnote6]这不是最健壮的测试------0的模式匹配将匹配确切的值为0，而不是1e-102或任何非常接近0的数值。
[^footnote6]:LISTS

模式匹配的作用有点像一个花哨的switch语句，可能会深入到它检查的表达式的结构中去，并提取结构的子表达式（我们稍后会进行解释）。ds之后跟着关键字match，以及用{ }包装着的一系列case，模式匹配就是这样一种表达式（*目标*或scrutinee）。每一个case在 => 左边构成一种模式（如Cons(x, xs)）， => 右边表示结果（如 x * product(xs)）。如果目标匹配中了一个case（见下文），这个case的结果就是整个模式匹配表达式的结果。如果多个模式都被匹配，Scala会选择第一个匹配的模式。

>侧边栏：Scala中的伴生对象
>我们经常会声明我们的数据类型和数据构造函数之外的*伴生对象*。这仅仅是一个具有数据类型相同名称的对象（例如List），其中包含我们把各种用来创建或操作数据类型的便捷函数。
>例如，如果我们需要一个函数def fill[A] (n:Int, a:A):List[A]，来创建一个包含n个元素a的拷贝的List，List的伴生对象会是放置这个函数的好地方。伴生对象更多的是Scala中的一种习惯。[^footnote7]如果我们愿意，也可以称这个模块为foo，但是称之为List意味着这个模块包含List的相关函数，当我们想定义一个可变参数函数apply时（在侧边栏中查看“Scala的可变参数函数），伴生对象也给了我们很好的List(1, 2, 3)的语义。


[^footnote7]:Scala对伴生对象有些特别支持，不过这里和我们的目标并不相关。

我们再来看一些关于模式匹配的例子：

 - List(1,2,3) match { case _ => 42 } 得出42。在这里我们使用了变量模式，_，下划线在这里表示任何表达式。我们可以使用x或foo来代替_，但是我们通常使用_来表示这个变量的值我们在结果中完全无关。[^footnote8]
 - List(1,2,3) match { case Cons(h,t) => h } 得出1。这里我们使用数据构造器模式配合变量来*捕获*或*绑定*一个目标的子表达式。
 - List(1,2,3) match { case Cons(_,t) => t } 得出List(2,3)。
 - List(1,2,3) match { case Nil => 42 }  导致运行时的MatchError。MatchError意味着没有任何模式的表达式匹配到目标。

是什么能决定一个模式是否匹配到表达式？一个模式可以像0.0或"hi"这样的，像x和xs用来匹配到任何事物的变量------变量由一个以小写字母开头的标识符或下划线表示，像Cons(x, xs)或Nil这样的数据构造器------它值会匹配到那些符合相应的形式的值（Nil作为一个模式只能匹配到值Nil，Cons(h, t)和Cons(x, xs)作为一种模式只匹配Cons值）。每一种模式的组件可以任意嵌套——————Cons(x1, Cons(x2, Nil)) 和Cons(y1, Cons(y2, Cons(y3, _))) 是有效的模式。当变量确实能够被分配到目标的子表达式使之*在结构上与目标相等*（make it structurally equivalent to the target）时，这个模式才能*匹配*中目标。匹配成功的结果是得到的结果表达式，将使那些被分配到子表达式的变量在当前作用域中可以被访问。

练习1：下面的match表达式的结果是什么？

	val x = List(1,2,3,4,5) match {
	  case Cons(x, Cons(2, Cons(4, _))) => x
	  case Nil => 42
	  case Cons(x, Cons(y, Cons(3, Cons(4, _)))) => x + y
	  case Cons(h, t) => h + sum(t)
	  case _ => 101
	}


我们强烈鼓励你试着把模式匹配在REPL中试验一下，去感受感受他是如何工作的。

>侧边栏:Scala中的可变参数函数
>上文中的List.apply函数是一个*可变参数*的函数，意味着它接受零个或多个A类型的参数。对于数据类型来说，这是在伴生对象中调用可变参数函数apply的一种常见用法，它可以很方便的构建数据类型的实例。通过在伴生对象中调用apply函数，我们可以用这种语法：List(1, 2, 3, 4)或List("hi", "bye")来调用它，当有有多个参数时我们要用逗号隔开（我们有时称之为*List字面语法*（list literal ）或*字面语法*(literal)）。
>可变参数函数只是提供一个小的语法糖来创造和明确的传递一个元素的Seq。Seq是Scala中的接口，它的实现类都是那些序列型的数据结构如List、Queue、Vector等等。在apply函数中，将被绑定到一个Seq[A]（[文档链接](http://www.scala-lang.org/api/current/scala/collection/immutable/Seq.html)），它具有函数head（返回第一个元素）和tail（返回除了头元素之外的所有元素）。
>我们可以使用语法x: _*，将Seq[A]类型的x变回一种可以传递给可变参数函数的变量，其中X可以是任何表达式：例如，List(x：_*) 甚至是List(List(1,2,3):_*)。

3.3函数式数据结构和数据共享
---

当数据是不可变的，我们如何编写函数呢？例如，从一个List中添加或删除元素？答案很简单。当我们添加一个元素1到现有List，例如xs，我们返回一个新的List，在这种情况下为Cons(1, xs)。因为List是不可变的，我们实际上不需要复制xs；而只是重用它。不可变数据的这种属性称为*数据共享*或*共享*。不可变数据的数据共享经常让我们在实现函数时更有效；我们可以随时返回不可变数据结构，而不必担心后续代码会修改我们的数据。完全没有必要悲观复制去避免修改或损坏。[^footnote9]

[^footnote9]:这种悲观的复制在大型程序中会成为一个问题，当数据可能会通过
一系列松散的组件时，每一个组件都可能被强制复制这个数据。使用不可变数据结构意味着永远不必复制数据，而只是在一个系统中的两个组件之间共享它，从而使这些组件松耦合。我们发现在*大型程序中*，FP往往比依赖的副作用的方法效率更高，得益于更多的数据和计算资源的共享。

以同样的方式，从List: val myList = Cons(x, xs)中"删除"头元素，我们只是简单地返回xs。而没有做真正的删除。原始的List，即myList仍然可用，安然无恙。我们说，函数式数据结构是*持久的*，意味着当操作数据结构时现有的引用从不会改变。

让我们试着用不同的方式来实现"修改"List函数。你可以把这些和其他函数都放在List的伴生对象中。

练习2：实现函数tail用来"移除"List的第一个元素。注意这个函数花费定长的时间。假如List是Nil，你在实现这个函数时会做出什么不同的选择呢？下一章我们还会再次讨论这个问题。

练习3：推广tail到函数drop，这个函数可以移除List的第n个元素。

	def drop[A](l: List[A], n: Int): List[A]

练习4：实现dropWhile[^footnote10]，这个函数从List中移除那些不满足断言的元素。再强调一下，注意这个函数花费的时间仅仅正比于要删除的元素数量------我们不需要复制整个List。

	￼def dropWhile[A](l: List[A])(f: A => Boolean): List[A]

[^footnote10]:dropWhile有两个参数列表，用来增强类型推断。详情见侧边栏。


>侧边栏：Scala中的类型推导
>当我们编写像dropWhile这样的函数时，我们往往会把List放置在第一个参数列表组中，而任何函数，比如接收List中的每一个元素的f，放置在后面的参数组里。我们可以用两对小括号来调用这个函数，比如dropWhile(xs)(f)，或者我们可以部分地应用这个函数，比如只提供第一个参数：dropWhile(xs)。这种用法返回一个接收其他参数的函数f。把函数的参数分组的主要原因是为了协助类型推断。如果我们这样做，Scala就可以确定f的类型，而不需要依赖任何注释，这基于它所知道的List的类型，这使函数使用起来更方便，特别是给f传入一个字面函数如x => x > 34，如果没有类型推断则要标注(x:Int) => x > 34。（这里并不显得很糟糕，但当你与更复杂的类型打交道时，每一次我们把字面函数传给一个像dropWhile这样的高阶函数时都不得不写明它的类型就会变得有些痛苦）。这是一个不幸的Scala编译器的限制；其他函数式语言如Haskell和OCaml则提供*完整的*推断、意味着几乎不需要任何类型注解。[^footnote11]

[^footnote11]:去查看本章的注释来获得更多信息，并链接到扩展阅读中


练习5：使用同样的思想，实现函数setHead，使用不同的值来替换List中的第一个元素。

数据共享通常带来令人惊讶的效率。例如，下面这个函数添加一个List的所有元素到另一个List的末尾。

	def append[A](a1: List[A], a2: List[A]): List[A] =
	  a1 match {
		case Nil => a2
	    case Cons(h,t) => Cons(h, append(t, a2))
	  }

注意，这个定义仅仅当第一个List耗尽之后才会复制值，所以它的运行时长仅由a1的长度确定。然后剩下的List指向a2。如果我们要实现接收两个Array的函数，我们将不得不把Array中的所有元素复制到结果中。

练习6：并不是所有事情都一帆风顺。实现一个函数init，它返回一个List中除了最后一个元素之外的所有元素。所以对于List(1,2,3,4)，init返回List(1,2,3)。为什么这个函数不能像tail一样，采用定长时间的实现？

	￼def init[A](l: List[A]): List[A]

因为一个单向链表（singly-linked list）的结构，任何时候我们想要更换Cons的尾部，即使它是List中最后的Cons，我们必须复制所有之前的Cons对象。编写纯函数式的支持高效的不同类型操作的数据结构，关键在于寻找有效地利用数据共享的方法，这往往意味着操作更多树型数据结构。我们不打算在这里介绍这些数据结构；因为现在，我们对于前人已经写好的函数式数据结构已经很满意了。例如在Scala标准库，已经有一个纯函数的Sequence实现：Vector（[文档链接](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Vector)），它支持以恒定时长进行随机access、update、head、tail、init、以及恒定时长在Sequence的前端或后端增加一个元素。

3.4List的递归和高阶函数的推广
---

让我们再看一下sum和product的实现。我们已经适当简化了product的实现，所以不包括检查0的"短路"逻辑：

	def sum(ints: List[Int]): Int = ints match {
	  case Nil => 0
	  case Cons(x,xs) => x + sum(xs)
	}
	
	def product(ds: List[Double]): Double = ds match {
	  case Nil => 1.0
	  case Cons(x, xs) => x * product(xs)
	}

请注意这两个函数的定义是多么相似。唯一不同的是，在该List为空的情况下，返回的值（sum返回0，product返回1），以及合并结果的操作（sum是+，product是*）。每当你遇到这样的重复代码，就像我们之前讨论过的，你可以把子表达式归纳为函数作为参数。如果子表达式引用了任何局部变量（如+操作引用了模式中的局部变量x和xs，product也是如此），那么就将子表达式转化为接收这些变量作为参数的函数。考虑所有这些情况，我们的函数将接收一个参数用来在空List的情况下作为返回值，以及一个用来在非空List中结合元素的函数。[^footnote12]

[^footnote12]:在Scala的标准库中，foldRight是一个List的方法，他的参数是被简单克里化后的，用来更好的进行类型推断。


清单3.3 Right Fold 以及简单使用

	def foldRight[A,B](l: List[A], z: B)(f: (A, B) => B): B = //1
	  l match {
		case Nil => z
	    case Cons(x, xs) => f(x, foldRight(xs, z)(f))
	  }
	  
	def sum2(l: List[Int]) =
	  foldRight(l, 0.0)(_ + _)

	def product2(l: List[Double]) =
	  foldRight(l, 1.0)(_ * _)

 1. 再重复一遍，在l和z的参数组之后，接着f的参数组。可以让类型推断决定f的输入类型。详情见侧边栏。


foldRight并不指定元素的类型，而且返回值也不需要和元素类型相同。可以这样描述foldRight：它用z和f分别替代了List的构造函数Nil和Cons。因此foldRight(Cons(a, Nil), z)(f)变成了f(a, z)，而foldRight(Cons(a, Cons(b, Nil)), z)(f)变成了f(a, f(b, z))。

让我们看一个例子。我们将*跟踪*foldRight(Cons(1, Cons(2, Cons(3, Nil))), 0)(_ + _)的展开，通过反复用foldRight的定义来替换用到它的地方。贯穿本书，我们都将使用程序跟踪。

	foldRight(Cons(1, Cons(2, Cons(3, Nil))), 0)(_ + _)
	1 + foldRight(Cons(2, Cons(3, Nil)), 0)(_ + _)
	1 + (2 + foldRight(Cons(3, Nil), 0)(_ + _))
	1 + (2 + (3 + (foldRight(Nil, 0)(_ + _))))
	1 + (2 + (3 + (0)))
	6

注意foldRight必须从头至尾遍历List中的所有元素（把每一帧推入栈），之后才开始化简它。

练习7：product函数可以使用foldRight来实现遇到0.0之后就立即停止递归并返回0.0吗？说出为什么？考虑当我们对一个大的List调用foldRight时短路可能如何发生。这是一个更深入的问题，我们将在几章之后再次回到这个问题。

练习8：试试把Nil和Cons自身传入foldRight会发生什么，如：foldRight(List(1,2,3), Nil:List[Int])(Cons(_, _))。[^footnote13]你觉得foldRight和数据构造器List之间是什么关系？

[^footnote13]:类型标注Nil:List[Int]在这里是必须指明的，因为不这样做Scala没办法推断出B的类型参数为List[Nothing]。

练习9：使用foldRight计算一个List的长度

	￼￼￼def length[A](l: List[A]): Int

练习10：foldRight不是尾递归的，当遇到超长的List时会StackOverflow。说服你自己这是个问题，并写出另一个List的递归函数，foldLeft是尾递归的，使用这个我们在前一章提到的技巧。下面是这个函数的签名。[^footnote14]

[^footnote14]:同理，foldLeft在Scala的标准库中已经作为List的一个方法，并且使用克里化进行更好的类型推断。所以你在实际使用时可以这样写：mylist.foldLeft(0,0)(_ + _)。

	￼def foldLeft[A,B](l: List[A], z: B)(f: (B, A) => B): B


练习11：把sum，product，以及计算List长度的函数length使用foldLeft实现。

练习12：写一个可以把List翻转过来（reverse）的函数（传入List(1,2,3)可以返回List(3,2,1)）。试试看能不能用fold来实现它。

练习13（困难）：你能基于foldRight来实现foldLeft吗。或使用foldLeft来实现foldRight。

练习14：使用foldLeft或foldRight来实现append函数。

练习15（困难）：写一个可以把一个List的List串联起来的函数。这个函数的执行时间必须是与所有List的总长度成正比的。尝试使用我们已经定义过的这些函数。

3.4.1 操作List的更多函数
----
这里还有更多操作List的函数，它们很有用。我们要在这里介绍其中的一部分。完成本章后，我们建议阅读Scala API文档看看还有什么其它函数。如果你发现自己写了一个显式的递归函数来做某种类型的List操作，去查查List的API看是否已经有现成的函数可用了。

当完成这一部分后，你将不会再出现一个自动感觉："什么时候去使用这些函数"。而是习惯于在这些函数中选择任何可能的方式来概括你要写的任何明确的递归函数，用它来处理List。如果你这样做的话，你将为你自己（重新）发现这些函数，并建立更多合适去使用它们的感觉。

>侧边栏：标准库中的Lists
>Scala标准库中包含了List（[API文档](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.List)），我们将在后面的章节中使用标准库的版本。
>我们在这里开发出的List和标准库版本之间的主要区别就是Cons被称为::，这是右结合的（所有以:结束的操作都是右结合的），所以1::2::Nil等于List(1,2,3)。当进行模式匹配时，case Cons(h, t)变成了case h :: t，这避免了在写这样的模式匹配：case h :: h2 :: t来从List中析构多余一个元素时，不得不使用嵌套圆括号。

练习16：写一个函数把一个包含整数的List在每一个元素上加1。（注意：这应该是一个纯函数，它返回一个新的List）

练习17：写一个函数，它可以把List[Double]中的每一个元素转为String。

练习18：写一个函数map，它抽象了修改List中每一个元素并保持List的结构。下面是它的方法签名[^footnote15]：

[^footnote15]:在标准库中map和flatMap是List的方法。


￼￼	def map[A,B](l: List[A])(f: A => B): List[B]

练习19：写一个函数filter，它会判断当List中的某个元素不满足断言时就把它移除。使用这个函数来移除List[Int]中所有的奇数。

练习20：写一个函数flatMap，它像map一样工作，除了它会返回一个List而不是单个的结果，而且这个List会插入到最终的结果List中。下面是它的方法签名：

	￼def flatMap[A,B](l: List[A])(f: A => List[B]):List[B] 

举个例子：flatMap(List(1, 2, 3))(i => List(i, i)) 会得到结果List(1, 1, 2, 2, 3, 3)。

练习21：你能用flatMap实现filter吗？

练习22：写一个函数，它接收两个List，通过相加对位的元素把它们合成一个List。比如，List(1, 2, 3) 和 List(4, 5, 6) 变为 List(5, 7, 9)。

练习23：抽象出一个函数，使你刚才写的函数不需要要特殊对待Int或其他可以相加的元素。

List还有很多其他有用的方法。当阅读了[API文档](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.List)后你可能想在REPL中尝试实现这些方法。这些方法在List[A]中被定义，而不是像我们在本章中所做的那样独立的定义。

	

 - def take(n: Int): List[A] ：返回一个List包含当前List的前n个元素
 - def takeWhile(f: A => Boolean): List[A]：返回一个List包含所有满足断言f的元素
 - def forall(f: A => Boolean): Boolean ：返回true假如所有元素都通过了断言f
 - def exists(f: A => Boolean): Boolean ：返回true假如有任何元素通过了断言f
 - scanLeft和scanRight和foldLeft与foldRight很像，但他们返回List的部分结果，而不是返回最终聚合的结果。

使用List的问题之一是，虽然我们可以使用非常通用的函数来表达操作或算法，但所得到的实现并不总是高效的------我们可能最终把相同的输入多次传递，或必须写明确的递归循环来允许提前终止。

练习24（难）：举个例子，实现hasSubsequence函数，用来检查是否一个List包含另一个List作为子序列。例如List(1, 2, 3, 4)包含List(1, 2)，List(2, 3)，List(4)等多个子序列。你可能很难寻找到一种简洁，且高效的纯函数实现。这没关系。函数实现的自然就好。我们会在后几章回到这个习题上来，并希望能改进它。注意：任何两个值x和y， 在Scala中都可以通过 x == y来表叫他们是否相等。

	￼def hasSubsequence[A](l: List[A], sub: List[A]):Boolean

3.5Tree
---
List只是*代数数据类型（*algebraic data type，ADT）中的一种。（有点混乱，ADT有时用在OO中代表“抽象数据类型”。）ADT是用一个或多个数据构造函数来定义的数据类型，这些构造函数每个都可能包含零个或多个参数。我们说，数据类型是其数据构造函数的合集或并集，每个数据构造函数是其参数的*乘积*（product），因此命名为代数数据类型。[^footnote16]

[^footnote16]:这个命名并不是巧合。其实是有着深层联系的，与“加法”和“乘法”类型去构成ADT，以及数的加法和乘法，不过这超出了本书的范围，

当你编码的ADT的数据类型、数据构造函数、类型API的相关模式的组成部分，以及其他的代码时，你可以参照某种特定的模式来编写。

>侧边栏：Scala中的Tuple类型（元组）
>对（Pairs）和其他元数的Tuple也是代数数据类型。他们像我们已经写过的那些ADT一样工作，但是有特殊的语法：
>
		scala> val p = ("Bob", 42)
		p: (java.lang.String, Int) = (Bob,42)
		
	scala> p._1
	res0: java.lang.String = Bob
	
	scala> p._2
	res1: Int = 42
	
	scala> p match { case (a,b) => b }
	res2: Int = 42

>在这个例子中，("Bob", 42)是一个对，它的类型是(String, Int)，这是Tuple2 [String, Int]（[API链接](http://www.scala-lang.org/api/current/index.html#scala.Tuple2)）。我们可以提取这个对的第一或第二哥元素（Tuple3将有一个_3方法，以此类推），我们可以像对其他任何case class一样对Tuple进行模式匹配。更高元数的Tuple类似，如果你感兴趣的话在REPL里去试一下吧。


代数数据类型也能用于定义其他的数据结构。让我们定义一个简单的二叉树结构：

	sealed trait Tree[+A]
	case class Leaf[A](value: A) extends Tree[A]
	case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A]

模式匹配同样提供了方便的方式来操作ADT中的元素。让我么来写一些函数：

练习25：写一个size函数，它计算Tree中的Node数量。

练习26：写一个函数maximum，它返回Tree[Int]中最大的元素。（注意：Scala中，你可以使用x.max(y)或x max y来计算x，y两个Int值中的最大值）

练习27：写一个函数depth，它返回Tree的根节点到任意一个叶结点的最长路径。

练习28：写一个函数map，它与List的map函数相似，可以使用传入的函数修改Tree每一个元素。

>侧边栏：ADT和它们的封装
>虽然代数数据类型由于把类型的内部表现对外暴露，这一点违反封装原则，使公众的内部表示的类型。但在FP，我们关注封装有点不同------我们通常不会有微妙的可变状态，这种可变状态一旦公开暴露，就会导致错误或违反不变性。公开一种类型的构造函数通常是好的，我们做出这样的决定是大概的原因是任何一个数据类型的公共接口应该都是一样的。[^footnote17]
>我们通常使用ADT时用到Case类，这些Case类是*关闭的*（是固定的）。对于List和Tree，改变了它们的数据构造函数将显著改变这些数据类型。List是一个*单向链表*------这是它的性质-------以及两个Case类，Nil和Cons，它们是公共API的一部分。我们当然可以写一些代码，来操作比List更抽象的API（我们将在本书后面的章节介绍），但隐藏这种信息可以作为一个单独的层来处理，而不是直接被融入到List中。

练习29：抽象size，maximum，depth，和map，写一个新的函数fold来提取他们相同的代码
概括。用一个更一般的函数来重新实现它们吧。你能在这个fold函数和List的left fold和right fold直减画一个比喻吗？

3.6总结
----

在这一章里我们介绍了一部分重要的概念。我们介绍了代数数据类型、模式匹配、并掩饰了如何使用纯函数来实现数据类型，包括单向链表。同时，通过本章的练习，我们希望你更自如的编写纯函数并归纳他们。我们将在后续章节中进一步开发这种技能[^footnote18]。

[^footnote18]:当你完成了更多的练习后，你可能会想要阅读附录中的Todo来讨论归纳函数的不同技巧。







[^footnote17]:Scala也可能会暴露出像Nil和Cons这样的模式，独立于类型的实际构造函数。



