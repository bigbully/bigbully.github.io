---
layout: post
title: 函数式编程scala第四章
description: 
category: scala
---

不依赖异常来处理错误
====


4.1介绍
----

在第一章里我们讲抛出一个异常会打破引用透明。让我们来看一个例子：

	def failingFn(i: Int): Int = {
	  val x: Int = throw new Exception("fail!")
	  try {
		val y = 42 + 5
		x+ y 
	  }
	  catch { case e: Exception => 43 }
	}

与表达式42 + 5产生的结果为47不同，表达式throw new Exception("fail!")不产生一个值------其“结果”是跳到最近的catch，这取决于上下文中它是如何执行的。使用throw和catch意味着我们不能在单纯的使用定义替换变量来推倒我们的程序------如果我们把x + y中的x用throw new Exception("fail!")替换，我们的程序就会产生不同的结果。

那么我们如何编写程序来处理错误呢？这将是你在本章中学到的。该技术基于一个简单的想法：与其抛出一个异常，我们不如返回一个值，它包含一个异常发生的场景。这个想法可能那些在C语言中使用返回码来处理过异常的人会有些熟悉，虽然在FP中它的处理方式有些许不同，我们一会儿就会看到。
	
4.2可能的替代方案
----

让我们考虑一个更现实的情况，我们可以使用一个异常，并寻找不同的方法来替代。这里是一个函数的实现，它计算List的平均值，如果列表是空的话，则没有结果：

	def mean(xs: Seq[Double]): Double = //1
	  if (xs.isEmpty)
	    throw new ArithmeticException("mean of empty list!")
	  else xs.sum / xs.length  //2


￼

 1. Seq是各种线性序列类型集合的常见接口。查看API文档获取更多的信息。
 2. Seq中的sum方法使用了一些魔法（我们不会到这里讨论），使得该方法只有只对数字类型的元素起作用。


mean函数是*偏函数*是一个例子，对于某些输入它没有定义。函数通常都是偏函数，因为它对这些输入做了一些输入除类型之外的假设[^footnote1]。你可能会在这种情况下抛出异常，但我们有一些其他的选择。让我们来重新审视一下我们的mean函数：

[^footnote1]:一个函数即便对于某些输入永远不会执行完成，但它也可能是偏函数。我们不会在这里讨论这种形式的偏函数------如果一个运行中的程序是无法从这种永不停止的状态中回复，或是无法从内部检测它的运行状态，那么我们自然没有任何好的办法去应对它。

第一种可能是返回某种Double类型的假值。我们可以在所有情况中简单地返回xs.sum / xs.length，但当输入是空Seq时会导致0／0，它的结果是double.NaN，或者我们可以返回一些其他的哨兵值（sentinel value）。在其他情况下，我们可能返回null而不是一个所需类型的值。但我们拒绝了这个解决方案，基于以下几个原因：

 - 它允许错误无声地传播，调用者可以忘记检查这种情况，而编辑器也不会通知调用者，这可能会导致在随后的代码不正常工作。错误的发生通常会在很后面的代码中才会被检测到。
 - 它不适用于多态代码。对于某些输出类型，即使我们想设置该类型的哨兵值，我们甚至都没有这种值！考虑一个像max这种找到序列中最大值的函数吧，它会根据一个自定义的比较函数来判断大小：def[A] (xs:Seq[A])(greater:(A, A) => Boolean): A。如果输入的是空的，我们没办法创造一个A的值。null也不可能用在这里，因为null只对一个非基础类型有效，而A类型在方法签名中完全没有被限制。
 - 它需要一个特殊的策略，或是调用方的调用约定------你要想适当的使用mean函数，要求调用方除了简单的调用mean函数获得结果之外还要做些其他处理。像这样对函数要求特殊的策略使得很难把它们传递到高阶函数，高阶函数必须对所有它们接收的函数仅仅作为参数之一，一致对待，并且通常只知道这些函数的类型，而不是任何特殊的策略或调用约定。

第二种可能是强制调用者提供一个参数，它在我们在无法应对的场景时告诉我们该怎样做：

	def mean_1(xs: IndexedSeq[Double], onEmpty: Double): Double =
	  if (xs.isEmpty) onEmpty
	  else xs.sum / xs.length

这使mean编程完整的函数，但它也有缺点------它需要直接调用者的清楚如何处理mean函数未定义的情况，把限制这种情况返回一个Double值。如果mean是在一个大型计算逻辑中的一部分被调用，我们希望当mean处理的情况未定义的花，就中止程序呢？或许我们想在这种情况下采用大型计算逻辑中的另一个完全不同的逻辑分支呢？只是简单的传入一个onEmpty参数并没有给我们这种自由。

我们需要一种方式去推迟做出如何处理这种未定义情况的决定，来让我们在何时的层面上处理这种情况。

4.3Option数据类型
----

该解决方案是在返回类型中明确表示：我们可能不总是返回一个明确的值。我们可以认为这种方案推迟了调用者做对错误处理的策略。我们引入一个新的类型，Option：

	sealed trait Option[+A]
	case class Some[+A](get: A) extends Option[A]
	case object None extends Option[Nothing]

Option有两个Case类：它可以被定义，这种Case类为Some，或者也可以不被定义，即None。我们使用Option来实现mean函数的定义：

	def mean(xs: Seq[Double]): Option[Double] =
	  if (xs.isEmpty) None
	  else Some(xs.sum / xs.length)

返回类型现在反映了mean的结果不总是明确的。我们仍然会为我们的函数返回一个声明类型的结果（现在是Option[Double]），所以mean现在是一个*完整的函数*了。它将每一个输入类型都转化成确定的输出类型的值。

4.3.1Option使用模式匹配
----
在程序设计中的偏函数大量存在，Option（我们稍后会讨论它相关的数据类型）是典型的FP的方式处理偏函数。你会看到在遍及Scala标准库中使用的Option，例如：

 - [Map在查找给定的Key](http://www.scala-lang.org/api/current/index.html#scala.collection.Map)时返回Option
 - headOption和lastOption 在[List或其他Iterable](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.List)中返回Option，当Sequence不为空时，结果包含Sequence中第一个或最后一个元素。

这并不是唯一的例子------我们会看到Option在不同情况是如何使用的。Option为什么这么方便，是因为可以让我们通过高阶函数来提炼出错误处理的通用模式，让我们从公式化的编写异常处理样板的代码中解放出来。

Option可以认为是最多只能包含一个元素的List，我们看到的许多List的函数在Option上都有类似的函数。让我们来看一下这些函数。我们将做一些稍微不同于上一章的事。在上一章中，我们将所有操作List对象的函数都放在List的伴生对象中。在本章中，我们会把我们的函数，尽可能的放在Option trait里面，所以他们可以用OO的语法调用（obj.fn(arg1) 或者 obj fn arg1而不是fn(obj, arg1) ）rg1））。这只是个风格上的选择，并不是说那种风格更好，我们将在这本书中同时使用这两种风格[footnote2]。

[footnote2]:一般来说，当函数有单一，清晰的操作对象时，我们会使用OO风格（比如List.map），其他情况我们会使用独立的函数式风格。


	trait Option[+A] {
	  def map[B](f: A => B): Option[B]
	  def flatMap[B](f: A => Option[B]): Option[B]
	  def getOrElse[B >: A](default: => B): B
	  def orElse[B >: A](ob: => Option[B]): Option[B]
	  def filter(f: A => Boolean): Option[A]
	}

这里有一些新生事物。getOrElse中default：= > B类型注释（以及orElse函数中同样的标注）表示这个参数将不会被运行除非函数需要使用它。现在先不要担心------我们将在下一章中进一步讨论它。另外，B >: A 这个函数的类型参数表示B必须是一个A的*超类*（supertype）。这是为了让Scala编辑器信服Option[+A]对于A的协变是安全的（编译器会假定Option[Dog]是Option[Animal]的子类）。对于orElse函数同理。对于当前我们的目标来说，这并不重要；OO风格的重要点是我们可以把操作对象的函数放置在trait中。

练习1：我们会在之后探究这些函数。但首先，作为练习，实现上述所有Option的函数。当你实现每个函数时，试着去思考它的意义，以及在什么情况下你会使用它们。以下是一些提示：

 - 你可以使用模式匹配，虽然你应该不借助模式匹配实现除了map和getOrElse之外的所有函数。(与后续章节相关，非常重要)
 - 对于map和flatMap，类型签名就足够决定它是怎样实现的
 - getOrElse会返回Some Case类中包含的结果，当Option是None时，返回给定的默认值
 - 当Option是被定义的，orElse函数会返回当前对象，否则，返回给定的Option[B]

虽然我们可以在Option上显式的使用模式匹配，但我们几乎总是使用上述高阶函数。关于什么时候使用他们，我们会尽可能的给出指导意见，所以如果现在还不完全清楚也不要担心。这里的目的主要是为了基本熟悉一下，当你开始写更多的函数是代码时就你可以识别这些模式。

map函数可以用来把Option中的结果进行转化，如果它存在的话。我们可以认为它是在假设没有发生错误时进行的计算------这也是一种延迟的错误处理的方式：

	case class Employee(name: String, department: String)
	
	val employeesByName: Map[String, Employee] = //1
	  List(Employee("Alice", "R&D"), Employee("Bob", "Accounting")).map(e => (e.name, e)).toMap //2
	  
	val dept: Option[String] = employeesByName.get("Joe").map(_.dept)

 1. 以String为键和Employee为值的字典或关联容器
 2. 把List[(A, B)]转化成Map[A, B]的快捷方法

在这里，employeesByName.get返回一个Option[Employee]，我们使用map来转换，它返回一个Option[String]代表员工所属的部门。

flatMap和map类似，但它提供了一种结果可以失败的转换。

练习2：实现方差variance函数（假如平均数是m，variance是math.pow(x - m, 2)），使用mean和flatMap[^footnote3]。

[^footnote3]: 方差Variance可以在一个传递中被计算，但处于教学目的，我们将使用2次传递来计算它。首先计算数据集的平均值，然后计算出平均值的平方差。


	￼def variance(xs: Seq[Double]): Option[Double]

filter可以把成功的值转换为失败，如果成功的值不匹配给定的断言。一个常见的模式是将Option，通过调用map，flatMap，和/或filter，然后使用getOrElse在最后处理错误。


	val dept: String =
	  employeesByName.get("Joe").
	  map(_.dept).
	  filter(_ != "Accounting").
	  getOrElse("Default Dept")

在这里使用getOrElse是为了把Option[String]转化成String，当键"Joe"在Map中不存的时候，或者"Joe"的部门名是"Accounting"时，返回一个默认的部门名。

常见的用法是做o.getOrElse(throw AnException("FAIL")) 来把None转化成一个异常。一般的经验法则是，只有在没有合理的程序能够捕捉到异常的时候，我们才会抛出异常------如果对某些调用方而言异常也许是可恢复的错误时，我们使用Option来给予它们灵活性。

4.3.2Option的组合和提升
---
这可能是容易得出的结论：一旦我们开始使用Option，它会感染我们的整个代码基础。你可以想象一下，任何一个接收或返回Option的方法的调用方将不得不修改逻辑来处理Some或None。但这根本不可能发生，而原因在于，我们可以将普通函数*提升*为操作Option的函数。

例如，map函数可以让我们操作类型Option[A]，使用A => B类型的函数，返回Option[B]。另一种看待这个问题的方式是：map把一个A => B类型的函数转化成Option[A] => Option[B]类型。如果我们使用明确的类型签名会看的更清晰一些：

	￼def lift[A,B](f: A => B): Option[A] => Option[B] = _ map f

作为你是用map的例子，让我们来再看一个返回Option的函数的例子：

	import java.util.regex._
	def pattern(s: String): Option[Pattern] =
	  try {
	    Some(Pattern.compile(s))
	  } catch {
	    case e: PatternSyntaxException => None
	  }


这个例子使用了Java标准库中的regex包，来把一个String解析成正则表达式[^footnote4]。如果这个String中有正则模式的语法错误（这不是一个有效的正则表达式），我们会捕捉到库函数抛出的异常，并返回None。在Pattern类的方法不需要知道关于Option的任何信息。我们可以使用map函数简单地*lift*他们：


	def mkMatcher(pat: String): Option[String => Boolean] =
  pattern(pat) map (p => (s: String) => p.matcher(s).matches) //1

 1. 这个API细节并不太重要，不过p.matcher(s).matches会检查String是否匹配模式p.


[^footnote4]:Scala运行在Java虚拟机上与所有现有的Java库完全兼容。因此我们可以像任何Scala函数一样调用Pattern.compile，这个Java函数。