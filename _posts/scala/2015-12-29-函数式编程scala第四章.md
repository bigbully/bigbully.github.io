---
layout: post
title: 函数式编程scala第四章
description: 
category: scala
---

不依赖异常来处理错误
====


4.1介绍
----

在第一章里我们讲抛出一个异常会打破引用透明。让我们来看一个例子：

	def failingFn(i: Int): Int = {
	  val x: Int = throw new Exception("fail!")
	  try {
		val y = 42 + 5
		x+ y 
	  }
	  catch { case e: Exception => 43 }
	}

与表达式42 + 5产生的结果为47不同，表达式throw new Exception("fail!")不产生一个值------其“结果”是跳到最近的catch，这取决于上下文中它是如何执行的。使用throw和catch意味着我们不能在单纯的使用定义替换变量来推倒我们的程序------如果我们把x + y中的x用throw new Exception("fail!")替换，我们的程序就会产生不同的结果。

那么我们如何编写程序来处理错误呢？这将是你在本章中学到的。该技术基于一个简单的想法：与其抛出一个异常，我们不如返回一个值，它包含一个异常发生的场景。这个想法可能那些在C语言中使用返回码来处理过异常的人会有些熟悉，虽然在FP中它的处理方式有些许不同，我们一会儿就会看到。
	
4.2可能的替代方案
----

让我们考虑一个更现实的情况，我们可以使用一个异常，并寻找不同的方法来替代。这里是一个函数的实现，它计算List的平均值，如果列表是空的话，则没有结果：

	def mean(xs: Seq[Double]): Double = //1
	  if (xs.isEmpty)
	    throw new ArithmeticException("mean of empty list!")
	  else xs.sum / xs.length  //2


￼

 1. Seq是各种线性序列类型集合的常见接口。查看API文档获取更多的信息。
 2. Seq中的sum方法使用了一些魔法（我们不会到这里讨论），使得该方法只有只对数字类型的元素起作用。


mean函数是*偏函数*是一个例子，对于某些输入它没有定义。函数通常都是偏函数，因为它对这些输入做了一些输入除类型之外的假设[^footnote1]。你可能会在这种情况下抛出异常，但我们有一些其他的选择。让我们来重新审视一下我们的mean函数：

[^footnote1]:一个函数即便对于某些输入永远不会执行完成，但它也可能是偏函数。我们不会在这里讨论这种形式的偏函数------如果一个运行中的程序是无法从这种永不停止的状态中回复，或是无法从内部检测它的运行状态，那么我们自然没有任何好的办法去应对它。

第一种可能是返回某种Double类型的假值。我们可以在所有情况中简单地返回xs.sum / xs.length，但当输入是空Seq时会导致0／0，它的结果是double.NaN，或者我们可以返回一些其他的哨兵值（sentinel value）。在其他情况下，我们可能返回null而不是一个所需类型的值。但我们拒绝了这个解决方案，基于以下几个原因：

 - 它允许错误无声地传播，调用者可以忘记检查这种情况，而编辑器也不会通知调用者，这可能会导致在随后的代码不正常工作。错误的发生通常会在很后面的代码中才会被检测到。
 - 它不适用于多态代码。对于某些输出类型，即使我们想设置该类型的哨兵值，我们甚至都没有这种值！考虑一个像max这种找到序列中最大值的函数吧，它会根据一个自定义的比较函数来判断大小：def[A] (xs:Seq[A])(greater:(A, A) => Boolean): A。如果输入的是空的，我们没办法创造一个A的值。null也不可能用在这里，因为null只对一个非基础类型有效，而A类型在方法签名中完全没有被限制。
 - 它需要一个特殊的策略，或是调用方的调用约定------你要想适当的使用mean函数，要求调用方除了简单的调用mean函数获得结果之外还要做些其他处理。像这样对函数要求特殊的策略使得很难把它们传递到高阶函数，高阶函数必须对所有它们接收的函数仅仅作为参数之一，一致对待，并且通常只知道这些函数的类型，而不是任何特殊的策略或调用约定。

第二种可能是强制调用者提供一个参数，它在我们在无法应对的场景时告诉我们该怎样做：

	def mean_1(xs: IndexedSeq[Double], onEmpty: Double): Double =
	  if (xs.isEmpty) onEmpty
	  else xs.sum / xs.length

这使mean编程完整的函数，但它也有缺点------它需要直接调用者的清楚如何处理mean函数未定义的情况，把限制这种情况返回一个Double值。如果mean是在一个大型计算逻辑中的一部分被调用，我们希望当mean处理的情况未定义的花，就中止程序呢？或许我们想在这种情况下采用大型计算逻辑中的另一个完全不同的逻辑分支呢？只是简单的传入一个onEmpty参数并没有给我们这种自由。

我们需要一种方式去推迟做出如何处理这种未定义情况的决定，来让我们在何时的层面上处理这种情况。

4.3Option数据类型
----

该解决方案是在返回类型中明确表示：我们可能不总是返回一个明确的值。我们可以认为这种方案推迟了调用者做对错误处理的策略。我们引入一个新的类型，Option：

	sealed trait Option[+A]
	case class Some[+A](get: A) extends Option[A]
	case object None extends Option[Nothing]

Option有两个Case类：它可以被定义，这种Case类为Some，或者也可以不被定义，即None。我们使用Option来实现mean函数的定义：

	def mean(xs: Seq[Double]): Option[Double] =
	  if (xs.isEmpty) None
	  else Some(xs.sum / xs.length)

返回类型现在反映了mean的结果不总是明确的。我们仍然会为我们的函数返回一个声明类型的结果（现在是Option[Double]），所以mean现在是一个*完整的函数*了。它将每一个输入类型都转化成确定的输出类型的值。

4.3.1Option使用模式匹配
----
在程序设计中的偏函数大量存在，Option（我们稍后会讨论它相关的数据类型）是典型的FP的方式处理偏函数。你会看到在遍及Scala标准库中使用的Option，例如：

 - [Map在查找给定的Key](http://www.scala-lang.org/api/current/index.html#scala.collection.Map)时返回Option
 - headOption和lastOption 在[List或其他Iterable](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.List)中返回Option，当Sequence不为空时，结果包含Sequence中第一个或最后一个元素。

这并不是唯一的例子------我们会看到Option在不同情况是如何使用的。Option为什么这么方便，是因为可以让我们通过高阶函数来提炼出错误处理的通用模式，让我们从公式化的编写异常处理样板的代码中解放出来。

Option可以认为是最多只能包含一个元素的List，我们看到的许多List的函数在Option上都有类似的函数。让我们来看一下这些函数。我们将做一些稍微不同于上一章的事。在上一章中，我们将所有操作List对象的函数都放在List的伴生对象中。在本章中，我们会把我们的函数，尽可能的放在Option trait里面，所以他们可以用OO的语法调用（obj.fn(arg1) 或者 obj fn arg1而不是fn(obj, arg1) ）rg1））。这只是个风格上的选择，并不是说那种风格更好，我们将在这本书中同时使用这两种风格[footnote2]。

[footnote2]:一般来说，当函数有单一，清晰的操作对象时，我们会使用OO风格（比如List.map），其他情况我们会使用独立的函数式风格。


	trait Option[+A] {
	  def map[B](f: A => B): Option[B]
	  def flatMap[B](f: A => Option[B]): Option[B]
	  def getOrElse[B >: A](default: => B): B
	  def orElse[B >: A](ob: => Option[B]): Option[B]
	  def filter(f: A => Boolean): Option[A]
	}

这里有一些新生事物。getOrElse中default：= > B类型注释（以及orElse函数中同样的标注）表示这个参数将不会被运行除非函数需要使用它。现在先不要担心------我们将在下一章中进一步讨论它。另外，B >: A 这个函数的类型参数表示B必须是一个A的*超类*（supertype）。这是为了让Scala编辑器信服Option[+A]对于A的协变是安全的（编译器会假定Option[Dog]是Option[Animal]的子类）。对于orElse函数同理。对于当前我们的目标来说，这并不重要；OO风格的重要点是我们可以把操作对象的函数放置在trait中。

练习1：我们会在之后探究这些函数。但首先，作为练习，实现上述所有Option的函数。当你实现每个函数时，试着去思考它的意义，以及在什么情况下你会使用它们。以下是一些提示：

 - 你可以使用模式匹配，虽然你应该不借助模式匹配实现除了map和getOrElse之外的所有函数。(与后续章节相关，非常重要)
 - 对于map和flatMap，类型签名就足够决定它是怎样实现的
 - getOrElse会返回Some Case类中包含的结果，当Option是None时，返回给定的默认值
 - 当Option是被定义的，orElse函数会返回当前对象，否则，返回给定的Option[B]

虽然我们可以在Option上显式的使用模式匹配，但我们几乎总是使用上述高阶函数。关于什么时候使用他们，我们会尽可能的给出指导意见，所以如果现在还不完全清楚也不要担心。这里的目的主要是为了基本熟悉一下，当你开始写更多的函数是代码时就你可以识别这些模式。

map函数可以用来把Option中的结果进行转化，如果它存在的话。我们可以认为它是在假设没有发生错误时进行的计算------这也是一种延迟的错误处理的方式：

	case class Employee(name: String, department: String)
	
	val employeesByName: Map[String, Employee] = //1
	  List(Employee("Alice", "R&D"), Employee("Bob", "Accounting")).map(e => (e.name, e)).toMap //2
	  
	val dept: Option[String] = employeesByName.get("Joe").map(_.dept)

 1. 以String为键和Employee为值的字典或关联容器
 2. 把List[(A, B)]转化成Map[A, B]的快捷方法

在这里，employeesByName.get返回一个Option[Employee]，我们使用map来转换，它返回一个Option[String]代表员工所属的部门。

flatMap和map类似，但它提供了一种结果可以失败的转换。

练习2：实现方差variance函数（假如平均数是m，variance是math.pow(x - m, 2)），使用mean和flatMap[^footnote3]。

[^footnote3]: 方差Variance可以在一个传递中被计算，但处于教学目的，我们将使用2次传递来计算它。首先计算数据集的平均值，然后计算出平均值的平方差。


	￼def variance(xs: Seq[Double]): Option[Double]

filter可以把成功的值转换为失败，如果成功的值不匹配给定的断言。一个常见的模式是将Option，通过调用map，flatMap，和/或filter，然后使用getOrElse在最后处理错误。


	val dept: String =
	  employeesByName.get("Joe").
	  map(_.dept).
	  filter(_ != "Accounting").
	  getOrElse("Default Dept")

在这里使用getOrElse是为了把Option[String]转化成String，当键"Joe"在Map中不存的时候，或者"Joe"的部门名是"Accounting"时，返回一个默认的部门名。

常见的用法是做o.getOrElse(throw AnException("FAIL")) 来把None转化成一个异常。一般的经验法则是，只有在没有合理的程序能够捕捉到异常的时候，我们才会抛出异常------如果对某些调用方而言异常也许是可恢复的错误时，我们使用Option来给予它们灵活性。

4.3.2Option的组合和提升
---
这可能是容易得出的结论：一旦我们开始使用Option，它会感染我们的整个代码基础。你可以想象一下，任何一个接收或返回Option的方法的调用方将不得不修改逻辑来处理Some或None。但这根本不可能发生，而原因在于，我们可以将普通函数*提升*为操作Option的函数。

例如，map函数可以让我们操作类型Option[A]，使用A => B类型的函数，返回Option[B]。另一种看待这个问题的方式是：map把一个A => B类型的函数转化成Option[A] => Option[B]类型。如果我们使用明确的类型签名会看的更清晰一些：

	￼def lift[A,B](f: A => B): Option[A] => Option[B] = _ map f

作为你是用map的例子，让我们来再看一个返回Option的函数的例子：

	import java.util.regex._
	def pattern(s: String): Option[Pattern] =
	  try {
	    Some(Pattern.compile(s))
	  } catch {
	    case e: PatternSyntaxException => None
	  }


这个例子使用了Java标准库中的regex包，来把一个String解析成正则表达式[^footnote4]。如果这个String中有正则模式的语法错误（这不是一个有效的正则表达式），我们会捕捉到库函数抛出的异常，并返回None。在Pattern类的方法不需要知道关于Option的任何信息。我们可以使用map函数简单地*提升*（lift）他们：


	def mkMatcher(pat: String): Option[String => Boolean] =
  pattern(pat) map (p => (s: String) => p.matcher(s).matches) //1

 1. 这个API细节并不太重要，不过p.matcher(s).matches会检查String是否匹配模式p.


[^footnote4]:Scala运行在Java虚拟机上与所有现有的Java库完全兼容。因此我们可以像任何Scala函数一样调用Pattern.compile，这个Java函数。


在这里，pattern(pat)调用将返回一个Option[Pattern]，如果pat是无效的则返回None。注意我们是如何在map*内*使用matcher和matches函数的。正因为他们在map内部，他们不需要知道外部的包装器Option。如果你觉得你还没有完全掌握它是如何生效的，那么使用替代模型在纸上一步一步的画一下吧，试一试pat是有效的和无效的两种情况。


通过使用for-comprehension也可以提升一个函数，for-comprehension在Scala中是编写一系列使map和flatMap便利的语法。我们迅速解释一下。首先，这里有一些例子：

	def mkMatcher_1(pat: String): Option[String => Boolean] =
	  for {
	    p <- pattern(pat)
	  } yield ((s: String) => p.matcher(s).matches)
	  
	def doesMatch(pat: String, s: String): Option[Boolean] =
	  for {
	    p <- mkMatcher_1(pat)
	  } yield p(s)


到目前为止，我们只是提升了只带一个参数的函数。但有些函数接收一个以上的参数，我们希望也能够提升他们。for-comprehension使之变得简单，我们可以结合任何我们想要的Option：

	def bothMatch(pat: String, pat2: String, s: String): Option[Boolean] =
	  for {
	    f <- mkMatcher(pat)
	    g <- mkMatcher(pat2)
	  } yield f(s) && g(s)

上文所示的for-comprehension是一个简单的语法糖。在其内部，Scala会把它翻译成普通的对map和flatMap的调用：

	￼￼def bothMatch_1(pat: String, pat2: String, s: String): Option[Boolean] =
	mkMatcher(pat) flatMap (f =>
	mkMatcher(pat2) map     (g =>
	f(s) && g(s)))

练习3：bothMatch是一个更泛化的模式的例子。写一个泛型函数map2，它可以把两个Option的值通过一个接收两个参数的函数合并起来。只要有任何一个Option的值是None，返回值就是None。下面是方法签名：

	def map2[A,B,C](a: Option[A], b: Option[B])(f: (A, B) => C): Option[C]

练习4：使用map2重新实现bothMatch函数。

	￼def bothMatch_2(pat1: String, pat2: String, s: String): Option[Boolean]


练习5：写一个函数sequence，他会把一个List[Option]合并成Option[List]，后者包含的这个List中有原始List中所有Some的值。如果原始List中包含哪怕一个None，那么函数返回的结果就是None。反之结果中包含全部所有Some的值。下面是函数签名：[^footnote5]


[^footnote5]:这是清晰的实例在面向对象的风格中却不可能的定义出来。这不应该是一个List的方法（因为我们不需要知道任何关于Option的信息），它又不应该是一个Option的方法。


	￼def sequence[A](a: List[Option[A]]): Option[List[A]]

有时我们会想用一个可能失败的函数map到一个List中，如果这个函数对任何一个元素执行返回None，则整个map的执行结果返回None。例如，将一个String List解析成一个Pattern List。在这种情况下，我们可以简单的对map的结果进行sequence：

	def parsePatterns(a: List[String]): Option[List[Pattern]] =
  sequence(a map pattern)

不幸的是，这个实现有一点低效，因为它便利了两次List。想要以某种方式对map的结果执行sequence正好与这个泛型函数traverse一致，traverse的方法签名为：

	￼￼def traverse[A, B](a: List[A])(f: A => Option[B]): Option[List[B]]

练习6：实现这个函数。它直接使用了map和sequence，但是尝试更高效的实现方式，它仅仅便利了一次List。事实上，sequence可以使用traverse来实现。


4.3.3Either数据类型
----

本章的主要思想是，我们可以用普通的值来表示失败和异常，并且我们可以编写函数抽象出错误处理和恢复的共同模式。Option并不是我们可以用于此目的的唯一数据类型，虽然它经常使用，而且相当简单。你可能会注意到的关于Option的一件事是，当发生异常时它不会告诉我们到底哪里出问题了。它所能做的就是给予我们None，表示没有任何计算结果。但有时我们想知道更多。例如，我们可能需要一个字符串来提供更多的信息，或者当异常抛出时，我们可能要知道这个错误究竟是什么。

我们可以制作一个数据类型，它可以包装我们所希望的关于失败的任何信息。有时只知道是否发生异常就已经足够了，那么我们使用Option；但其他情况我们需要更多信息。在这一节中，我们将通过对Option的简单扩展，即数据类型Either，来让我们跟踪失败的原因。让我们来看看它的定义：

	sealed trait Either[+E, +A]
	case class Left[+E](value: E) extends Either[E, Nothing]
	case class Right[+A](value: A) extends Either[Nothing, A]


Either和Option一样只有两个Case Class。本质区别在于这两种Case Class都能装一个值。Either数据类型用一种非常普遍的方式代表两种事物中的一种。我们可以说它是一个两种*不相交类型的结合*。当我们用它来表示成功或失败时，按惯例，Left构造函数表示失败的Case[^footnote6]。

[^footnote6]:Either经常用来更普遍的包装两种可能性，在不值得定义出新的数据类型的情况下。我们将在这本书中看到一些这样的例子。

>侧边栏：标准库中的Option和Either
>Scala标准库中包含了Option和Either（[Option API](http://www.scala-lang.org/api/current/index.html#scala.Option)和[Either API](http://www.scala-lang.org/api/current/index.html#scala.util.Either)），大多数函数在本章定义的函数都有标准库的版本。但也有一些确实的函数，尤其是sequence， traverse，和map2。
>你最好看一下Option和Either的API，这样就可以了解他们之间的区别。尤其是Either，并没有想我们一样直接定义一个右偏（right-biased）的flatMap函数，而是依赖于清晰的left和right投影函数（projection function）。你可以从API中得到更多细节。

让我们重新来看一下mean的例子，这次当失败的情况下我们返回一个String：

	def mean(xs: IndexedSeq[Double]): Either[String, Double] =
	  if (xs.isEmpty)
	    Left("mean of empty list!")
	  else
	    Right(xs.sum / xs.length)


有时我们可能希望包含更多关于该错误的信息，例如堆栈跟踪记录来显示源代码中的错误的位置。在这种情况下，我们可以简单的在Left中返回一个Exception:

	def safeDiv(x: Double, y: Double): Either[Exception, Double] =
	  try {
	    Right(x / y)
	  } catch {
	    case e: Exception => Left(e)
	  }


练习7：在Either中实现map，flatMap，orElse，map2，来操作Right的值。

	trait Either[+E, +A] {
	  def map[B](f: A => B): Either[E, B]
	  def flatMap[EE >: E, B](f: A => Either[EE, B]): Either[EE, B]
	  def orElse[EE >: E,B >: A](b: => Either[EE, B]): Either[EE, B]
	  def map2[EE >: E, B, C](b: Either[EE, B])(f: (A, B) => C):
    Either[EE, C]
	}



注意这些函数的定义，Either现在可以在for-comprehension中使用了：

	for {
	  age <- Right(42)
	  name <- Left("invalid name")
	  salary <- Right(1000000.0)
	} yield employee(name, age, salary)

这个表达式会得到Left("invalid name")。当然，Left("invalid name")可以是像foo(x,y,z)一样的任意表达式的执行Left结果。

练习8：在Either中实现sequence和traverse。

作为最终的例子，这里有个一map2的应用，函数mkPerson会在构建正确的Person对象前验证名字和年龄：

	case class Person(name: Name, age: Age)
	sealed class Name(val value: String)
	sealed class Age(val value: Int)
	
	def mkName(name: String): Either[String, Name] =
	  if (name == "" || name == null) Left("Name is empty.")
	  else Right(new Name(name))
	  
	def mkAge(age: Int): Either[String, Age] =
	  if (age < 0) Left("Age is out of range.")
	  else Right(new Age(age))
	  
	def mkPerson(name: String, age: Int): Either[String, Person] =
	  mkName(name).map2(mkAge(age))(Person(_, _))

练习9：以上是函数的实现，即使名字和年龄都不正确，map2也只是汇报一个错误。如果我们想要同时汇报两个错误，我们需要如何修改呢？你会修改map2或是mkPerson的方法签名吗？还是你会创建一个新的数据类型，在捕获异常这方面比Either做的更好，需要使用一些新的结构吗？orElse，traverse和sequence这三个函数在新的数据类型中有什么不一样的行为吗？

4.4总结
----

使用代数数据类型，如Option和Either，我们可以用模块化、可组合的、容易推导的方式处理错误。在本章中，我们已经开发了一些高阶函数来操作错误，如果我们只是抛出异常，我们就不可能这样操作错误。有了这些新的工具在手，在我们的程序中异常应该只在真正无法复原的情况下才会被保留。

