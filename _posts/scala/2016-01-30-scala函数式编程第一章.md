---
layout: post
title: scala函数式编程第一章
description: 
category: scala
---

什么是函数式编程
=====

函数式编程的前提：只用*纯函数*（pure functions），即*无副作用*（NO side effects）的函数构建程序。

什么是副作用？

 - 给变量重新赋值
 - 修改数据结构
 - 在一个对象上设置属性
 - 抛出一个异常或是因为错误而中断
 - 在控制台打印信息或是读取用户输入
 - 读写文件
 - 在屏幕上画图


函数式编程限制了我们*如何*去写程序，但并没有限制我们能写出*什么样*的程序。

一个例子：我们希望实现一个咖啡店的程序，顾客可以在这里购买咖啡，并用信用卡付款。

传统的OO是如何做的：

	class Cafe {
	
		def buyCoffee(cc: CreditCard): Coffee = {
			val cup = new Coffee()
			cc.charge(cup.price)
			cup
		}
	}




这段代码值得商榷的地方有几个：

 1. CreditCard不应该知道如何与信用卡公司交互、授权、付账、或是保留付款记录。即charge方法放在CreditCard中并不合适。
 2. buyCoffee方法很难测试，因为每跑一次都会造成信用卡付款。
 3. 函数buyCoffee的输入是信用卡，输出是咖啡，但是在函数体内包含了使用信用卡付款的逻辑，这就是明显的副作用。


改进一下：

	class Cafe {
		def buyCoffee(cc: CreditCard, p: PaymentService): Coffee = {
			val cup = new Coffee()
			p.charge(cc, cup.price)
			cup
		}
	}

虽然副作用仍然存在，不过用过引入PaymentService把支付操作由外部服务实现，这样当我们进行测试时，只需要Mock PaymentService就可以了。

虽然这种实现方式把测试的问题解决了，如何重用仍然是个问题。

如果一个顾客要购买一打咖啡，想要重用buyCoffee函数，我们需要在一个循环体中重复调用12次这个函数。但这样就会造成重复刷卡12次，显然没有任何一个顾客或咖啡店希望这么做。

函数式的风格：

	class Cafe {
		def buyCoffee(cc: CreditCard): (Coffee, Charge) = {
			val cup = new Coffee()
		    (cup, Charge(cc, cup.price))
		}
	}


	case class Charge(cc: CreditCard, amount: Double) {

		def combine(other: Charge): Charge =
			if (cc == other.cc)
			    Charge(cc, amount + other.amount)
			￼else
				throw new Exception("Can't combine charges to different cards")

	}

 1. buyCoffee现在返回一个Tuple，其中包含购买的咖啡和账单。这样我们就把生成账单的逻辑和拿着账单去罚款的逻辑解耦了。这让我们更容易对购买咖啡的逻辑进行复用。
 2. Charge类自带的combine方法可以把同一信用卡的账单进行合并

如何处理同时购买多杯咖啡：

	class Cafe {

		def buyCoffee(cc: CreditCard): (Coffee, Charge) = ...

		def buyCoffees(cc: CreditCard, n: Int): (List[Coffee], Charge) = {
			val purchases: List[(Coffee, Charge)] = List.fill(n)(buyCoffee(cc))
			val (coffees, charges) = purchases.unzip
			(coffees, charges.reduce((c1,c2) => c1.combine(c2)))
		}

	}

当然我们得到Charge之后仍然可以使用PaymentService来处理，但Cafe作为咖啡店来说，完全不用关心信用卡是如何进行支付的。

所有方法都可以很简单的进行测试，无需Mock。

例如顾客可能在咖啡店中呆了很长时间，用好几张信用卡多次付款。用函数式编程可以轻松把所有账单按信用卡分组进行合并。


	def coalesce(charges: List[Charge]): List[Charge] = charges.groupBy(_.cc).values.map(_.reduce(_ combine _)).toList

这里使用的groupBy，map，reduce等方法是函数式编程中最常见的几种方法，因为函数式编程所做的只是把输入转化为输出的，所以逻辑很容易以链式编程表现，这种方式在函数式编程中非常常见，而且代码可读性很高。

究竟什么是纯函数
---

纯函数指没有副作用的函数，且纯函数易于进行推导。

如果副作用对外不可见时，函数仍然是纯函数。

函数式编程中“函数”这一术语即指代纯函数。

引用透明，替换模型
---

在函数式编程的程序中，任何一个表达式都可以使用他的结果进行替换，而不造成任何副作用。例如任何出现2+3的地方，我们都可以直接用5来替换。

引用透明提供了一条约束：一个函数造成的任何影响，仅仅得到它的返回值。这条约束使我们可以用一种即简单又自然的方式对程序执行的结果进行推导，即替换模型。

真实世界中的函数式编程：由纯函数核心和副作用外层组成。

到底什么是纯函数？

一个函数除了把输入参数计算出结果之外，没有任何可见的影响，称之为无副作用。没有副作用的函数就是纯函数。

引用透明：在任何程序中，一个表达式可以被它的结果替换，而不改变程序的含义。

替换模型：当表达式是引用透明的，程序的执行就相当于求解代数等式。只需要展开每一个表达式，然后用它的结果进行替换，最后进行化简。

纯函数使编写程序更加的模块化和可组合的 。因为它能把计算逻辑与“如何处理结果”、“如何获得输入”隔离。计算逻辑可以认为是黑盒的，你根本不用担心在计算的过程中会有任何副作用在对上下文造成影响。






