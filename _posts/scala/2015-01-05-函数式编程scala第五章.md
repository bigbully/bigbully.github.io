---
layout: post
title: 函数式编程scala第五章
description: 
category: scala
---

严格和懒惰v2
====


在第三章，我们介绍了纯函数数据结构，使用单向链表作为示例。我们涵盖了很多操作List的函数———map，filter，foldLeft，foldRight，zipWith等等。我们注意每一个函数在被调用时都遍历了输入的List来构造一个新的List作为输出。

想象一下，假设你有一副扑克牌，你需要移除其中奇数数字的扑克，然后再移除所有皇后。理想情况下，你会从这一副扑克牌中一张一张的同时查找是否是皇后或奇数数字的扑克牌。这样做比先移除所有奇数数字扑克再从剩余扑克中查找皇后来的更加高效。不过Scala是用下面的代码来做的[^footnote1]:

	scala> List(1,2,3,4) map (_ + 10) filter (_ % 2 == 0) map (_ * 3)
	List(36,42)

[^footnote1]:我们在这里使用的是Scala的标准库，这里map和filter都是List的方法，而不是第三章我们编写的独立的函数。


在这个表达式中，map(_ + 10)会产生一个临时List，并把它传给filter(_ % 2 == 0)，这之后又会构建一个新的List，再传给map(_ * 3)，产生最终的List。换句话说，每一次变换都产生了一个临时List，它只被用来作为下一次变换的输入，之后就立即被抛弃。

试想一下这个程序是如何被执行的。假如我们自己动手写出执行的过程，它的步骤如下所示：

	List(1,2,3,4) map (_ + 10) filter (_ % 2 == 0) map (_ * 3)
	List(11,12,13,14) filter (_ % 2 == 0) map (_ * 3)
	List(12,14) map (_ * 3)
	List(36,42)

这里我们展现了在表达式执行时每一次代换的结果（比如，在第一行到第二行的变换过程中，我们基于map函数的定义使用List(11,12,13,14)替换了List(1,2,3,4) map (_ + 10)）[^footnote2]。结果很清楚的展现出map和filter在调用时是如何遍历输入的List并创建出输出的List。如果我们能够想办法把一系列变换融合到一块儿在一次遍历中执行，而不产生任何临时数据结构岂不是更好？我们确实可以使用while循环来重写这段代码，但是理想情况下，我们希望能保留这种high-level的组合式的编程风格来自动的搞定这个问题。我们希望使用像map和filter这样的高阶函数来代替手动操作循环。

[footnote2]:从上文的程序跟踪可以看出，不完全跟踪每一个子表达式的执行更加有说明性。例如，在这种情况下，我们忽略List(1,2,3,4) map (_ + 10)的完整展开。我们完全可以“进入”map的定义并跟踪它的执行，但我们选择了省略这个层次的详细信息。

事实证明我们可以通过使用*非严格*（non-strictness）的方式来完成（或更通俗一些，“懒惰”（laziness））。在本章中，我们将解释这是什么意思，我们将通过一个懒惰的List类型的实现，融合序列的转换工作。虽然建设一个“更好的”List是本章的动机，不过我们会发现通常非严格方式是提高效率和函数式程序模块化的基本技术。

5.1严格和非严格函数
---

在我们接触lazy List之前，我们需要介绍一些基础知识。什么是严格和非严格，这些概念在Scala中是如何表现的？

非严格是函数的一个性质。如果一个函数是非严格的，意味着函数可以选择*不*对其参数中的一个或多个求值。相反，一个*严格*的函数总是对其参数进行求值。在大多数编程语言中，严格函数是规范，大多数语言甚至不提供定义非严格函数的方法。除非我们明确指出，否则在Scala中的任何函数定义都是严格的（迄今为止我们在书中定义的所有函数都是严格的）。作为一个例子，考虑下面的函数：

￼	def square(x: Double): Double = x * x

当你调用square(41.0 + 1.0)时，会得到求值后的结果42.0，因为square函数是严格的。如果你调用square(sys.error("failure"))，你会在square有机会做任何事情之前得到一个异常，因为sys.error("failure") 表达式会在传给square之前就被求值。

虽然我们还没有学到在Scala中表示非严格的语法，但你肯定熟悉非严格的概念。例如，短路Boolean函数&&和| |，在任何编程语言中都存在的函数，当然也包括Scala，它是非严格。你可能曾经认为i&&和| |是内置语法，语言的一部分，但我们也可以认为他们是可以选择不去对参数求值的函数。函数&&接收两个Boolean类型的参数，但只有当第一个值为true时才对第二个参数求值：

	scala> false && { println("!!"); true } //不会打印任何信息
	res0: Boolean = false


同理||仅仅当第一个参数为false时才对第二个参数求值：

	scala> true || { println("!!"); true} // 不会打印任何信息
	res1: Boolean = true

另一个非严格的例子是Scala中的if控制结构：

	val result = if (input.isEmpty) sys.error("empty input") else input

if的语言结构也可以被认为是一个接收三个参数的函数：一个Boolean类型的状态，一个当状态为true时用来返回的类型A，以及另一个当状态为false时用来返回的类型 A。if函数是非严格的，因为它不会对所有的参数进行求值。要更精确一些的话，我们会说，if函数的状态参数是严格的，因为状态总是会被求值来确定会去执行哪一个分支，而true和false场景的两个分支是非严格的，因为它们之中只有一个分支会基于状态的结果会被求值。

在Scala中，我们可以写一个非严格函数来接收一些不会被求值的参数。我们会通过说明到底发生了什么来明确展示它是如何做的，然后再给出一些更优雅的Scala内置语法。下面是一个非严格的if函数的定义：

	def if2[A](cond: Boolean, onTrue:() => A, onFalse:() => A): A =
	  if (cond) onTrue() else onFalse()

	if (a < 22,
		() => println("a"),  //这里的函数字面量语法创建了 () => A 
		() => println("b")
	)

我们想传入不被求值的参数，需要在他们的类型前添加 () => 。类型 () => A 是一个函数，它接收0个参数，并返回一个A[footnote3]。通常，没有被执行的表达式挺长被称为Thunk（形实替换程序），我们可以*强迫*thunk去执行表达式，并返回一个结果。我们这样做，通过执行这个函数，穿一个空的参数列表，就像onTrue()或onFalse()。同理，if2的调用方需要明确的创建thunk，紧跟着的语法的如同我们已经见过的函数字面语，遵循同样的规则。

[^footnote3]:事实上类型() => A是一个Function0[A]的语法别名。

总之，这种语法非常清楚的表明发生了什么------我们在非严格参数的地方传递了一个没有参数的函数，然后显式调用此函数，获得函数体的结果。但这是如此常见的情况以至于Scala提供了一些更好的的语法：


	def if2[A](cond: Boolean, onTrue: => A, onFalse: => A): A =
		if (cond) onTrue else onFalse

我们想传入的不被执行的参数会有一个剪头 => 在他们的类型之前。在函数体中，我们不需要特别的执行一个被=>修饰的参数。我们只需像从前一样引用该标识符。我们也不需要做任何特殊的事情来调用这个函数。我们只是用普通的函数调用的语法，而Scala会帮我们把这段表达式包装成一个thunk：

	scala> if2(false, sys.error("fail"), 3)
	res2: Int = 3

无论哪种语法，一个不被执行的参数传给一个函数之后，会在函数体中每个被引用的地方被执行一次。也就是说，Scala不会（默认）缓存的参数执行的结果：

	scala> def maybeTwice(b: Boolean, i: => Int) = if (b) i+i else 0
	maybeTwice: (b: Boolean, i: => Int)Int
	
	scala> val x = maybeTwice(true, { println("hi"); 1+41 })
	hi
	hi
	x: Int = 84

这里，我们在maybeTwice的函数体内引用了i两次，我们为了让它在执行的时候特别明显，特意传入一个代码块：{println("hi"); 1 + 41}， 这个代码块会打印hi作为返回结果42的副作用。表达式1 + 41将被计算两次。幸运的是，如果我们希望只执行一次表达式，我们可以通过使用lazy关键字显示的缓存值：

	scala> def maybeTwice2(b: Boolean, i: => Int) = { 
		 | lazy val j = i
	     | if (b) j+j else 0
		 | }
	maybeTwice: (b: Boolean, i: => Int)Int
	
	scala> val x = maybeTwice2(true, { println("hi"); 1+41 })
	hi
	x: Int = 84

在val声明前加lazy关键字会导致Scala延迟其右边的表达式执行直到它第一次被引用，并且还将会缓存结果，因此计算结果的j被再次引用时不会触发重复计算。

>侧边栏：关于严格的正式定义
>如果对表达式的执行永远不会停止或者抛出错误，而不是返回一个确定的值，我们就说这个表达式不会终止，或执行到底。对于函数f，如果表达式f(x)对于所有可以执行到底的输入参数x都可以执行到底，我们就说函数f是严格的。

作为一个最后的术语，在Scala中一个非严格的函数会*按名称*接收参数，而不是*按值*接收参数。

5.2一个扩展示例：Lazy List
---

现在，让我们回到本章开头所提出的问题。我们将探讨在函数式程序中Lazy如何用来提高效率和模块化的，使用Lazy List，或称为Stream的例子。我们将看到通过使用Lazy如何在Stream上的把转换链融合成一个单一的过程。下面是一个简单的Stream定义。其中有一些新鲜事物，我们一会儿将会讨论。

关于Stream的简单定义：


	sealed trait Stream[+A]
	case object Empty extends Stream[Nothing]
	case class Cons[+A](h: () => A, t: () => Stream[A]) extends Stream[A] //一个非空Stream由head和tail组成，它们都是非严格的。由于技术上的限制，这里的Thunk必须明确指明，而不能使用按名称的参数。
	
	object Stream {
		def cons[A](hd: => A, tl: => Stream[A]): Stream[A] = {
			lazy val head = hd //我们缓存了head和tail作为Lazy值，避免被重复执行
			lazy val tail = tl
			Cons(() => head, () => tail)
		} //这是一个构建非空Stream的聪明的构造器
	  
		def empty[A]: Stream[A] = Empty //一个构建空的类型A的Stream的聪明的构造器
		
		def apply[A](as: A*): Stream[A] =
			if (as.isEmpty) empty else cons(as.head, apply(as.tail: _*)) //一个方便的可变参数方法，用来构造包含多个元素的Stream
	}	

Stream类型看上去和List差不多，除了Cons数据构造器明确接收Thunk（() => A 和 () => Stream[A]）而不是严格的值。如果我们想检查或是遍历整个Stream，我们需要强制执行这些Thunk，如同我们早先定义的if2一样。举例，下面是一个函数用来选择性的提取Stream的Head。

	def headOption: Option[A] = this match { case Empty => None
		case Cons(h, t) => Some(h()) //通过使用h()，明确的强制执行了Thunk h
	}

注意我们通过h()明确的强制执行了h，但除此之外，这段代码与List中提取Head完全一致。不过Stream的可以按需执行部分元素的特性非常有用（我们并没有执行Cons的Tail），我们一会儿看到它的作用。

5.2.1记住Stream，避免重复计算
----








注意的cons函数的参数是非严格的。因此，Stream中的head和tail流将不会被执行，直到遇到第一次请求。我们有时会中缀表示法来编写cons，使用右结合的操作符 #::，所以1 #:: 2 #:: empty 相当于cons(1，cons(2, empty))。如同我们在第三章把 :: 加到List trait中一样，我们也可以把 #:: 加到Stream trait中，虽然也有一些恼人的需要越过的附加操作来正确的实现非严格。如果你感兴趣的它是如何实现这个语法，你可以查看相关的代码。

在继续之前，让我们写一下帮助函数来使检查Stream变得容易一些。

练习1：写一个函数将Stream转化为一个List，这将迫使它被执行，让我们在REPL中试试看。你可以把Stream转化成标准库中的List类型。你可以把这个函数和其他函数都放在Stream trait中。

	def toList: List[A]

练习2：写一个take函数，它返回Stream的前n个元素。

	￼def take(n: Int): Stream[A]

练习3：写一个函数takeWhile，它从前返回所有Stream中满足给定断言的元素

	def ￼takeWhile(p: A => Boolean): Stream[A]

你可以把take和toList一起使用来检测我们生成的Stream。比如：打印Stream(1, 2, 3).take(2).toList。


5.3把程序描述从执行中分离出来
---

Lazy让我们把程序的描述和表达式的执行分开来。这给了我们一个强大的能力------我们可以选择描述一个比我们需要的“更大”的表达式，但只执行它的一部分。作为一个例子，考虑一下foldRight------我们可以像List中实现的方式一样实现它，但我们选择用Lazy的方式实现：

	def foldRight[B](z: => B)(f: (A, => B) => B): B =
	  uncons match {
	    case Some((h, t)) => f(h, t.foldRight(z)(f))
	    case None => z
	  }


上面的实现和我们在List中写的非常相似，但是注意组合函数f，f的第二个参数是不严格的。如果f选择不执行它的第二个参数，这将终止提前遍历。我们可以看到，通过使用foldRight实现exists，来检查在Stream中是否存在满足给定断言的元素。

	def exists(p: A => Boolean): Boolean =
	  foldRight(false)((a, b) => p(a) || b)

由于foldRight可以终止提前遍历，我们可以利用它来实现exists而不是写一个显式的递归函数来处理提前终止。这就是一个简单的例子，它把描述一种计算行为的关注点和执行的关注点分离开来，相比把两者纠缠在一起，这使我们的描述更加可以被重用。这种对关注点的分离是函数式编程的中心思想。

练习4：实现fooAll函数，它会检查Stream中的所有元素是否满足断言。你的实现应该能够在发现一个不匹配的值时立刻中断遍历。


	def forAll(p: A => Boolean): Boolean

练习5：使用foldRight去实现takeWhile。只有当它的结果被其他表达式求值时才会逐渐构建出一个新的Stream。





