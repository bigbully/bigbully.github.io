---
layout: post
title: 函数式编程scala第五章
description: 
category: scala
---

Strictness and5laziness
====


在第三章，我们介绍了纯函数数据结构，使用单向链表作为示例。我们涵盖了很多操作List的函数———map,filter,foldLeft,foldRight,zip等等。我们注意每一个函数在被调用时都遍历了输入的List构造出一个新的List作为输出。

想象一下，假设你有一副扑克牌，你需要移除其中奇数数字的扑克，然后再移除所有皇后。理想情况下，你会从这一副扑克牌中一张一张的同时查找是否是皇后或奇数数字的扑克牌。这样做比先移除所有奇数数字扑克再从剩余扑克中查找皇后来的更加高效。不过下面的代码是Scala如何做的[^footnote1]:

	scala> List(1,2,3,4) map (_ + 10) filter (_ % 2 == 0) map (_ * 3)
List(36,42)

[^footnote1]:我们在这里使用的是Scala的标准库，这里map和filter都是List的方法，而不是第三章我们编写的独立的函数。


在这个表达式中，map(_ + 10)会产生一个临时List，并把它传给filter(_ % 2 == 0)，这之后又会构建一个新的List，再传给map(_ * 3)，产生最终的List。换句话说，每一次变换都产生了一个临时List，它只被用来作为下一次变换的输入，之后立即被抛弃。

试想一下这个程序是如何被执行的。加入我们自己动手写出执行的过程，它的步骤如下所示：

	List(1,2,3,4) map (_ + 10) filter (_ % 2 == 0) map (_ * 3)
	List(11,12,13,14) filter (_ % 2 == 0) map (_ * 3)
	List(12,14) map (_ * 3)
	List(36,42)

这里我们展现了在表达式执行时每一次代换的结果（比如，在第一行到第二行的变换过程中，我们基于map函数的定义使用List(11,12,13,14)替换了List(1,2,3,4) map (_ + 10)）。[^footnote2]结果很清楚的展现出map和filter在调用时是如何遍历输入的List并创建出输出的List。如果我们能够想办法把一系列变换融合到一块儿在一次遍历中执行，而不产生任何临时数据结构岂不是更好？我们确实可以使用while循环来重写这段代码，但是理想情况下，我们希望能保留这种high-level的组合式的编程风格来自动的搞定这个问题。我们希望使用像map和filter这样的高阶函数来代替手动操作循环。

[footnote2]:

