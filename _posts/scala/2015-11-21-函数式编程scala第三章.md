---
layout: post
title: 函数式编程scala第三章
description: 
category: scala
---

函数式数据结构
====


3.1介绍
----

我们在介绍中说，函数式程序不会更新变量或修改数据结构。这就提出了一个紧迫的问题------什么样的数据结构*可以*用在函数式编程中，我们如何在Scala中定义它们，我们如何操作这些数据结构？在本章中，我们将学习*函数式数据结构*的概念，和如何定义和使用这种数据结构。我们将以此为契机，介绍如何在函数式编程中定义数据类型，了解*模式匹配*的相关技术，亲自编写和归纳纯函数。

本章有大量的练习，特别是为最后一点提供帮助------编写和归纳纯函数。一些练习可能极具挑战。一如既往，如果你需要的话，请咨询一下提示或答案，或者线上寻求帮助。

3.2定义函数式数据结构
----

函数式的数据结构（别惊讶！）只使用纯函数操作。记住，一个纯函数可能只接受一些值作为输入，并产生一个值作为输出。它可不会适当改变数据或执行其他副作用。*因此，函数式数据结构是不可变的*。例如，空列表，（Scala中记作List()或Nil）像整数3或4一样是永恒不变的。正如对3 + 4求值的结果是一个新数字7，而并没有修改3或4一样，把两个列表合并到一起（语法是：对于列表a和b，a ++ b）产生一个新的列表，但不改变两个输入的列表。

这难道不意味着我们最终进行了大量数据的额外复制吗？有些令人惊讶的是，答案是“不”。在研究了链表（singly-linked list），这个也许是最无处不在的函数式数据结构之后，我们将再次回到这个问题。这里的定义在精神上（虽然简单了一些）和Scala标准库中定义的List数据类型一致。这个代码清单使用了很多新的语法和概念，如果不是所有的东西都能明白也不用担心，首先我们会详细讨论它[^footnote1]。

[^footnote1]:注意------sum和product方法的实现在这里没有使用尾递归。我们会在本章中完成它们的尾递归版本。

清单3.1 链表

	package fpinscala.datastructures
	
	sealed trait List[+A] //1
	case object Nil extends List[Nothing] //2
	case class Cons[+A](head: A, tail: List[A]) extends List[A]
	
	object List { //3
	  def sum(ints: List[Int]): Int = ints match { //4
	    case Nil => 0
	    case Cons(x,xs) => x + sum(xs)
	}
	
	  def product(ds: List[Double]): Double = ds match {
	    case Nil => 1.0
	    case Cons(0.0, _) => 0.0
	    case Cons(x,xs) => x * product(xs)
	}
	
	  def apply[A](as: A*): List[A] = //5
	    if (as.isEmpty) Nil
	    else Cons(as.head, apply(as.tail: _*))
	    
	  val example = Cons(1, Cons(2, Cons(3, Nil))) //6
	  val example2 = List(1,2,3)
	  val total = sum(example)
	}

 1. List数据类型
 2. List的构造函数
 3. List的伴生对象
 4. 模式匹配例子
 5. 可变参数函数的语法
 6. 创建一个链表

让我们先来看看数据类型的定义，它以关键字sealed trait开始。在一般情况下，我们使用特质（trait）关键字引入一个数据类型。特质是一个抽象的接口，它可选包含一些方法的具体实现。在这里，我们声明一个不包含方法的特质，List。在前面添加sealed意味着我们的特质必须在这个文件中声明所有的实现[^footnote2]。


[^footnote2]:我们也可以使用抽象类来替代特质。从技术上讲，一个抽象类可以包含构造函数，在面向对象的意义上，这用来区分它和特质，特质不能包含构造函数。这种区别和我们现在的目的没有关系。


声明了两种List的实现或*数据构造器*（data constructors）（每种实现都附带关键字case），代表两种可能的List的形式-------它可以是*空的*，由数据构造器Nil表示，也可以是非空的（数据构造器Cons，通常是"construct"的简称），在这种情况下，它由最初的元素，head，后面跟着一个List（可能为空）剩余的元素（tail）。

清单3.2 List的数据构造器

	case object Nil extends List[Nothing]
	case class Cons[+A](head: A, tail: List[A]) extends List[A]

正如函数可以是多态的，数据类型也可以，通过在sealed trait List之后添加类型参数[+A]，之后可以在Cons数据构造器中使用参数A，我们已经声明了List数据类型包含的元素是多态的，这意味着我们可以使用同一定义在Int（表示为List[Int]），Double（表示为List[Double]），String（标识为List[String]），等等。（+表示这个类型参数A是*协变*的------你可以在工具栏"关于型变的更多信息"中查询到）。

一个数据构造器给我们提供了一个哟过年来构造数据类型的方式（case object Nil让我们用Nil来构造一个空的List，而case class Cons让我们用Cons(1, Nil)，Cons(1, Cons(2, Nil))，等形式来构造一个非空List），还介绍了一种模式，可以用于模式匹配，如同函数sum和product一样。

>工具栏：关于型变的更多信息
>在声明trait List[+A]时，在类型参数前的+是一个*型变注解*，它表示A是List的*协变*或称之为"积极"的参数。这意味着，例如，假设Dog是Animal的子类，那么List[Dog]被认为是List[Animal]的子类。（一般情况下，对于任何类型X和Y，如果X是类型Y的子类，那么就List[X]就是List[Y]的子类）。如果我们把在A前面的"+"去掉在前面的一个，这将使List的类型参数从协变变为*不变*。
>但请注意，Nil继承自List[Nothing]。Nothing是所有类型的子类，这就意味着加之型变注解，Nil可以被认为是List[Int]，List[Double]等，这正是我们想要的。
>这些关于型变的担忧在当下并不是很重要，更多的是Scala通过子类进行数据构造的一部分，所以如果你并没有彻底搞清楚也不要担心[^footnote3]。

[^footnote3]:完全不使用型变注解来写代码当然是可行的，函数签名有人哼简单（而类型推断往往会变得更糟）。除非另有说明，我们将在这本书中使用型变注释，但是你应该对这两种方法都有自由的尝试。

3.2.1模式匹配
----

让我们看看函数sum和product的细节，这两个函数我们放在object List中，有时被称为List的*伴生对象*（见侧栏）。这两种定义都使用了模式匹配。

	def sum(ints: List[Int]): Int = ints match {
	  case Nil => 0
	  case Cons(x,xs) => x + sum(xs)
	}
	
	def product(ds: List[Double]): Double = ds match {
	  case Nil => 1.0
	  case Cons(0.0, _) => 0.0
	  case Cons(x, xs) => x * product(xs)
	}


正如你可能期望的，sum函数表示空List的和为0，非空List的和是第一个元素x加上剩余的元素xs的和[^footnote4]，同样的，product函数表示一个空List的乘积为1，以0.0开始的List的乘积为0.0，[^footnote5]，非空List的乘积是第一个元素乘以剩余的元素的乘积。注意这两个函数都是递归定义的，在编写函数处理像List一样（Cons数据构造器递归的引用了自身）的递归数据类型时很常见。

[^footnote4]:这里的x和xs我们可以用任何名称，但它是常见的惯例使用xs，ys，as，bs作为一个序列的变量名，x，y，z，a或b为一个序列中单一元素的变量名。另一种常见的命名规则是h表示列表的第一个元素（列表中的"头"），t表示其余的元素（"尾"），l表示一个完整的列表。
[^footnote5]:LISTS



[^footnote6]这不是最健壮的测试------0的模式匹配将匹配确切的值为0，而不是1e-102或任何非常接近0的数值。
[^footnote6]:LISTS

模式匹配的作用有点像一个花哨的switch语句，可能会陷入检查表达式的结构，并提取结构的子表达式（我们稍后会进行解释）。据介绍，一个表达式（*目标*或scrutinee），就像ds紧跟着的关键字match，和用{ }包装着的一系列case。每一个case在 => 左边构成一种模式（如Cons(x, xs)）， => 右边表示结果（如 x * product(xs)）。如果目标匹配中了一个case（见下文），这个case的结果就是整个模式匹配表达式的结果。如果多个模式都被匹配，Scala会选择第一个匹配的模式。

>侧边栏：Scala中的伴生对象
>我们经常会声明我们的数据类型和数据构造函数之外的*伴生对象*。这仅仅是一个具有数据类型相同名称的对象（例如List），其中包含我们把各种用来创建或操作数据类型的方便函数。
>如果，例如，我们需要一个函数def fill[A] (n:Int, a:A):List[A]，来创建一个包含n个元素a的拷贝的List，List的伴生对象会是放置这个函数的好地方。伴生对象更多的是Scala中的一种习俗。[^footnote7]如果我们想的花也可以称这个模块为foo，但是称之为List意味着这个模块包含List的相关函数，也给了我们很好的List(1, 2, 3)的语义当我们想定义一个可变参数函数apply（在侧边栏中查看“Scala的可变参数函数）。


[^footnote7]:Scala对伴生对象有些特别支持，不过这里和我们的目标并不相关。

我们再来看一些关于模式匹配的例子：

 - List(1,2,3) match { case _ => 42 } 得出42。在这里我们使用了变量模式，_，下划线在这里表示任何表达式。我们可以使用x或foo来代替_，但是我们通常使用_来表示这个变量的值我们在结果中完全不关系。[^footnote8]
 - List(1,2,3) match { case Cons(h,t) => h } 得出1。这里我们使用数据构造器模式配合变量来*捕获*或*绑定*一个目标的子表达式。
 - List(1,2,3) match { case Cons(_,t) => t } 得出List(2,3)。
 - List(1,2,3) match { case Nil => 42 }  导致运行时的MatchError。MatchErro意味着没有任何模式的表达式匹配到目标。

是什么能决定一个模式是否匹配到表达式？一个模式可以包含文字，像0.0或"hi"，变量如x和xs用来匹配到任何事物，变量由一个以小写字母开头的标识符或下划线表示，数据构造器如Cons(x, xs)或Nil，它值会匹配到那些符合相应的形式的值（Nil作为一个模式只能匹配到值Nil，Cons(h, t)和Cons(x, xs)作为一种模式只匹配Cons值）。每一种模式的组件可以任意嵌套——————Cons(x1, Cons(x2, Nil)) 和Cons(y1, Cons(y2, Cons(y3, _))) 是有效的模式。当变量确实能够被分配到目标的子表达式使之*在结构上与目标相等*（make it structurally equivalent to the target）时，这个模式才能*匹配*中目标。匹配成功的结果是得到的结果表达式，将使那些被分配到子表达式的变量在当前作用域中可以被访问。

练习1：下面的match表达式的结果是什么？

	val x = List(1,2,3,4,5) match {
	  case Cons(x, Cons(2, Cons(4, _))) => x
	  case Nil => 42
	  case Cons(x, Cons(y, Cons(3, Cons(4, _)))) => x + y
	  case Cons(h, t) => h + sum(t)
	  case _ => 101
	}


我们强烈鼓励你试着把模式匹配在REPL中试验一下，去感受感受他是如何工作的。

>侧边栏:Scala中的可变参数函数
>上文中的List.apply函数是一个*可变参数*的函数，意味着它接受零个或多个A类型的参数。对于数据类型来说，这是在伴生对象中调用可变参数函数apply的一种常见用法，它可以很方便的构建数据类型的实例。通过在半生对象中调用apply函数，我们可以用这种语法：List(1, 2, 3, 4)或List("hi", "bye")来调用它，当有有多个参数时我们要用逗号隔开（我们有时称之为*List字面语法*（list literal ）或*字面语法*(literal)）。
>可变参数函数只是提供一个小的语法糖来创造和明确的传递一个元素的Seq。Seq是Scala中的接口，它的实现类都是那些序列型的数据结构如List、queue、vector等等。在apply函数中，将被绑定到一个Seq[A]（[文档链接](http://www.scala-lang.org/api/current/scala/collection/immutable/Seq.html)），它具有函数head（返回第一个元素）和tail（返回除了头元素之外的所有元素）。
>我们可以使用语法x: _*，将Seq[A]类型的x变回一种可以传递给可变参数函数的变量，其中X可以是任何表达式：例如，List(x：_*) 甚至是List(List(1,2,3):_*)。

3.3函数式数据结构和数据共享

当数据是不可变的，我们如何编写函数，例如，去从一个List中添加或删除元素？答案很简单。当我们添加一个元素1到现有List，例如xs，我们返回一个新的List，在这种情况下为Cons(1, xs)。因为List是不可变的，我们实际上不需要复制xs；而只是重用它。不可变数据的这种属性称为*数据共享*或*共享*。不可变数据的数据共享经常让我们在实现函数时更有效；我们可以随时返回不可变数据结构，而不必担心后续代码会修改我们的数据。完全没有必要悲观复制去避免修改或损坏。[^footnote9]

[^footnote9]:这种悲观的复制在大型程序中会成为一个问题，当数据可能会通过
一系列松散的组件时，每一个组件都可能被强制复制这个数据。使用不可变数据结构意味着永远不必复制数据，而只是在一个系统中的两个组件之间共享它，从而使这些组件松耦合。我们发现在*大型程序中*，FP往往比依赖的副作用的方法效率更高，得益于更多的数据和计算资源的共享。

以同样的方式，从List: val myList = Cons(x, xs)中"删除"头元素，我们只是简单地返回xs。而没有做真正的删除。原始的List，即myList仍然可用，安然无恙。我们说，函数式数据结构是*持久的*，意味着当操作数据结构时现有的引用从不会改变。

让我们试着用不同的方式来实现"修改"List函数。你可以把这些和其他函数都放在List的伴生对象中。

练习2：实现函数tail用来"移除"List的第一个元素。注意这个函数花费定长的时间。假如List是Nil，你在实现这个函数时会做出什么不同的选择呢？下一章我们还会再次讨论这个问题。

练习3：推广tail到函数drop，这个函数可以移除List的第n个元素。

	def drop[A](l: List[A], n: Int): List[A]
I
练习4：实现dropWhile[^footnote10]，这个函数从List中移除那些不满足断言的元素。再强调一下，注意这个函数花费的时间仅仅正比于要删除的元素数量------我们不需要复制整个List。

	￼def dropWhile[A](l: List[A])(f: A => Boolean): List[A]

[^footnote10]:dropWhile有两个参数列表，用来增强类型推断。详情见侧边栏。


>侧边栏：Scala中的类型推导
>当我们编写像dropWhile这样的函数时，我们往往会把List放置在第一个参数列表组中，而任何函数，比如接收List中的每一个元素的f，放置在后面的参数组里。我们可以用两对小括号来调用这个函数，比如dropWhile(xs)(f)，或者我们可以部分地应用这个函数，比如只提供第一个参数：dropWhile(xs)。这种用法返回一个接收其他参数的函数f。把函数的参数分组的主要原因是为了协助类型推断。如果我们这样做，Scala就可以确定f的类型，而不需要依赖任何注释，这基于它所知道的List的类型，这使函数使用起来更方便，特别是给f传入一个字面函数如x => x > 34，如果没有类型推断则要标注(x:Int) => x > 34。（这里并不显得很糟糕，但当你与更复杂的类型打交道时，每一次我们把字面函数传给一个像dropWhile这样的高阶函数时都不得不写明它的类型就会变得有些痛苦）。这是一个不幸的Scala编译器的限制；其他函数式语言如Haskell和OCaml则提供*完整的*推断、意味着几乎不需要任何类型注解。[^footnote11]

[^footnote11]:去查看本章的注释来活的更多信息，并链接到扩展阅读中


练习5：使用同样的思想，实现函数setHead，使用不同的值来替换List中的第一个元素。

数据共享通常带来令人惊讶的效率。例如，下面这个函数添加一个List的所有元素到另一个List的末尾。

	def append[A](a1: List[A], a2: List[A]): List[A] =
	  a1 match {
		case Nil => a2
	    case Cons(h,t) => Cons(h, append(t, a2))
	  }

注意，这个定义仅仅当第一个List耗尽之后才会赋值值，所以它的运行仅由a1的长度确定。然后剩下的List指向a2。如果我们要实现接收两个Array的函数，我们将不得不把Array中的所有元素复制到结果中。

练习6：并不是所有事情都一帆风顺。实现一个函数init，它返回一个List中除了最后一个元素之外的所有元素。所以对于List(1,2,3,4)，init返回List(1,2,3)。为什么这个函数不能像tail一样，采用定长时间的实现？

	￼def init[A](l: List[A]): List[A]

因为一个单链表（singly-linked list）的结构，任何时候我们想要更换Cons的尾部，即使它是List中最后的Cons，我们必须复制所有之前的Cons对象。编写纯函数式的支持高效的不同类型操作的数据结构，关键在于寻找有效地利用数据共享的方法，这往往意味着操作更多树型数据结构。我们不打算在这里介绍这些数据结构；因为现在，我们对于前人已经写好的函数式数据结构已经很满意了。很可能有这样一个例子，在Scala标准库，已经有一个纯函数的Sequence实现：Vector（[文档链接](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Vector)），它支持以恒定时长进行随机access、update、head、tail、init、以及恒定时长在Sequence的前端或后端增加一个元素。

3.4List的递归和高阶函数的推广
---

让我们再看一下sum和product的实现。我们已经适当简化了product的实现，所以不包括检查0的"短路"逻辑：

	def sum(ints: List[Int]): Int = ints match {
	  case Nil => 0
	  case Cons(x,xs) => x + sum(xs)
	}
	
	def product(ds: List[Double]): Double = ds match {
	  case Nil => 1.0
	  case Cons(x, xs) => x * product(xs)
	}

请注意这两个函数的定义是多么相似。唯一不同的是，在该List为空的情况下，返回的值（sum返回0，product返回1），以及合并结果的操作（sum是+，product是*）。每当你遇到这样的重复代码，就像我们之前讨论过的，你可以把子表达式概括为函数作为参数。如果子表达式引用了任何局部变量（如+操作引用了模式中的局部变量x和xs，product也是如此），那么就将子表达式转化为接收这些变量作为参数的函数。考虑所有这些情况，我们的函数将接收一个参数用来在空List的情况下作为返回值，以及一个用来在非空List中结合元素的函数。[^footnote12]

[^footnote12]:在Scala的标准库中，foldRight是一个List的方法，他的参数是被简单克里化后的，用来更好的进行类型推断。


清单3.3 Right Fold 以及简单使用

	def foldRight[A,B](l: List[A], z: B)(f: (A, B) => B): B = //1
	  l match {
		case Nil => z
	    case Cons(x, xs) => f(x, foldRight(xs, z)(f))
	  }
	  
	def sum2(l: List[Int]) =
	  foldRight(l, 0.0)(_ + _)

	def product2(l: List[Double]) =
	  foldRight(l, 1.0)(_ * _)

 1. 再重复一遍，在l和z的参数组之后，接着f的参数组。可以让类型推断决定f的输入类型。详情见侧边栏。


foldRight并不指定元素的类型，而且返回值也不需要和元素类型相同。可以这样描述foldRight：它用z和f分别替代了List的构造函数Nil和Cons。因此foldRight(Cons(a, Nil), z)(f)变成了f(a, z)，而foldRight(Cons(a, Cons(b, Nil)), z)(f)变成了f(a, f(b, z))。

让我们看一个例子。我们将*跟踪*foldRight(Cons(1, Cons(2, Cons(3, Nil))), 0)(_ + _)的展开，通过反复用foldRight的定义来替换用到它的地方。贯穿本书，我们都将使用程序的跟踪。

	foldRight(Cons(1, Cons(2, Cons(3, Nil))), 0)(_ + _)
	1 + foldRight(Cons(2, Cons(3, Nil)), 0)(_ + _)
	1 + (2 + foldRight(Cons(3, Nil), 0)(_ + _))
	1 + (2 + (3 + (foldRight(Nil, 0)(_ + _))))
	1 + (2 + (3 + (0)))
	6

注意foldRight必须从头至尾遍历List中的所有元素（把每一帧推入栈），之后才开始化简它。

练习7：product函数可以使用foldRight来达到遇到0.0之后就立即停止递归并返回0.0吗？说出为什么？考虑当我们对一个大的List调用foldRight时短路可能如何发生。这是一个更深入的问题，我们将在几章之后再次回到这个问题。

练习8：试试把Nil和Cons自身传入foldRight会发生什么，如：foldRight(List(1,2,3), Nil:List[Int])(Cons(_, _))。[^footnote13]你觉得foldRight和数据构造器List之间是什么关系？

[^footnote13]:类型标注Nil:List[Int]在这里是必须指明的，因为不这样做Scala会办法推断出B的类型参数为List[Nothing]。

练习9：使用foldRight计算一个List的长度

	￼￼￼def length[A](l: List[A]): Int

练习10：foldRight不是尾递归的，当遇到超长的List时会StackOverflow。说服你自己这是个问题，并写出另一个List的递归函数，foldLeft是尾递归的，使用这个我们在前一章提到的技巧。下面是这个函数的签名。[^footnote14]

[^footnote14]:同理，foldLeft在Scala的标准库中已经作为List的一个方法，并且使用克里化进行更好的类型推断。所以你在实际使用时可以这样写：mylist.foldLeft(0,0)(_ + _)。

	￼def foldLeft[A,B](l: List[A], z: B)(f: (B, A) => B): B


练习12：把sum，product，以及计算List长度的函数length使用FoldLeft实现。
