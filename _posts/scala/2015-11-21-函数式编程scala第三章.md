---
layout: post
title: 函数式编程scala第三章
description: 
category: scala
---

函数式数据结构
====


3.1介绍
----

我们在介绍中说，函数式程序不会更新变量或修改数据结构。这就提出了一个紧迫的问题------什么样的数据结构*可以*用在函数式编程中，我们如何在Scala中定义它们，我们如何操作这些数据结构？在本章中，我们将学习*函数式数据结构*的概念，和如何定义和使用这种数据结构。我们将以此为契机，介绍如何在函数式编程中定义数据类型，了解*模式匹配*的相关技术，亲自编写和归纳纯函数。

本章有大量的练习，特别是为最后一点提供帮助------编写和归纳纯函数。一些练习可能极具挑战。一如既往，如果你需要的话，请咨询一下提示或答案，或者线上寻求帮助。

3.2定义函数式数据结构
----

函数式的数据结构（别惊讶！）只使用纯函数操作。记住，一个纯函数可能只接受一些值作为输入，并产生一个值作为输出。它可不会适当改变数据或执行其他副作用。*因此，函数式数据结构是不可变的*。例如，空列表，（Scala中记作List()或Nil）像整数3或4一样是永恒不变的。正如对3 + 4求值的结果是一个新数字7，而并没有修改3或4一样，把两个列表合并到一起（语法是：对于列表a和b，a ++ b）产生一个新的列表，但不改变两个输入的列表。

这难道不意味着我们最终进行了大量数据的额外复制吗？有些令人惊讶的是，答案是“不”。在研究了链表（singly-linked list），这个也许是最无处不在的函数式数据结构之后，我们将再次回到这个问题。这里的定义在精神上（虽然简单了一些）和Scala标准库中定义的List数据类型一致。这个代码清单使用了很多新的语法和概念，如果不是所有的东西都能明白也不用担心，首先我们会详细讨论它[^footnote1]。

[^footnote1]:注意------sum和product方法的实现在这里没有使用尾递归。我们会在本章中完成它们的尾递归版本。

清单3.1 链表

	package fpinscala.datastructures
	
	sealed trait List[+A] //1
	case object Nil extends List[Nothing] //2
	case class Cons[+A](head: A, tail: List[A]) extends List[A]
	
	object List { //3
	  def sum(ints: List[Int]): Int = ints match { //4
	    case Nil => 0
	    case Cons(x,xs) => x + sum(xs)
	}
	
	  def product(ds: List[Double]): Double = ds match {
	    case Nil => 1.0
	    case Cons(0.0, _) => 0.0
	    case Cons(x,xs) => x * product(xs)
	}
	
	  def apply[A](as: A*): List[A] = //5
	    if (as.isEmpty) Nil
	    else Cons(as.head, apply(as.tail: _*))
	    
	  val example = Cons(1, Cons(2, Cons(3, Nil))) //6
	  val example2 = List(1,2,3)
	  val total = sum(example)
	}

 1. List数据类型
 2. List的构造函数
 3. List的伴生对象
 4. 模式匹配例子
 5. 可变参数函数的语法
 6. 创建一个链表

让我们先来看看数据类型的定义，它以关键字sealed trait开始。在一般情况下，我们使用特质（trait）关键字引入一个数据类型。特质是一个抽象的接口，它可选包含一些方法的具体实现。在这里，我们声明一个不包含方法的特质，List。在前面添加sealed意味着我们的特质必须在这个文件中声明所有的实现[^footnote2]。


[^footnote2]:我们也可以使用抽象类来替代特质。从技术上讲，一个抽象类可以包含构造函数，在面向对象的意义上，这用来区分它和特质，特质不能包含构造函数。这种区别和我们现在的目的没有关系。



