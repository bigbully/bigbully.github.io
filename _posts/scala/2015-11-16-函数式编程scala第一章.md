---
layout: post
title: 函数式编程scala第一章
description: 
category: scala
---

什么是函数式编程v2
===

1.1函数式编程的基本前提
---

函数式编程（FP）建立在一个简单的但是影响深远的前提下：我们构建程序只使用*纯函数*（pure functions），换句话说，没有*副作用*的函数（side effects）。这到底是什么意思呢？下列任何一种行为都会带来副作用：

 - 给变量重新赋值
 - 适当的修改某种数据结构
 - 在一个对象上设置属性
 - 抛出一个异常或是因为错误而中断
 - 在控制台打印信息或是读取用户输入
 - 读写文件
 - 在屏幕上画图

试想一下不采用上述任何一种行为如何去编程吧。这可能有点难以想象。这能编出任何有用的程序吗？假如你不能给变量重新赋值，如何写一个像循环这样的简单程序？如何使用那些会改变的数据？或是如何在不抛出异常的情况下处理错误？我们如何进行像在屏幕上画图或是从文件中读取这样的IO操作？

答案就是我们仍然可以写出同样的程序------这些程序可以做到一切上面提到的事情，甚至更多------而不引入任何副作用。函数式编程限制了我们*如何*去写程序，而不是能写出*什么样*的程序。因为我们使用纯函数会使程序更加*模块化*，因此接受这种限制会给我们带来了巨大的好处。因为模块化，纯函数更容易被测试，被重用，被并行化，被泛化，被推导。

但收获这些优势需要我们重新审视编程行为，从最简单的任务开始做起，一步一步向上攀登。在很多场景之下，我们会发现许多看似不得不产生副作用的程序完全可以用纯函数代替。其他一些场景，我们可以想办法用某种方式构建代码，使它即便有副作用存在，但是并不会被*察觉*（比如，我们可以改变那些声明在函数内的数据，只要我们能保证这些数据不会被外部引用）。尽管如此，FP在程序组织方面产生了激进的提升------最简单的循环，到高级程序架构。FP的风格与众不同，但是非常优美，并且很接近于我们希望你来欣赏的那种编程方式。

在这本书中，你将学习FP的概念和原理，它们适用于各个层次的编程。我们在本章将从解释纯函数是什么和它不是什么开始 ，我们也尝试给你一个想法，为什么纯粹的结果会更有利于模块化和代码重用。

1.2（纯）函数到底是什么
---
一个函数，输入是A类型，输出是B类型（用scala表示就是：A => B），是把每一个A类型的值a计算出唯一的B类型的值b，这种b是由a唯一确定的。

例如，一个函数 intToString 的类型 Int => String， 会把每一个整数转化成对应的字符串。因此，如果它确实是一个*函数*，它只做这一件事情。

换句话说，一个函数除了基于输入计算出给定的结果之外，没有在执行过程中产生任何能观察到的其他影响；我们就说它是没有副作用的。我们有时会将这种函数称为*纯*函数使之更加明确。其实你早就已经知道纯函数了。考虑整数的加法函数（+）。它接收两个整数返回一个整数。对于任何两个给定的整数，它将*始终返回相同的整数值*。另一个例子是在Java、scala以及很多其他的编程语言中用到的获得字符串长度的函数，对于任何给定的字符串，每次调用函数都返回相同的长度。

我们可以通过使用*引用透明*（referential transparency， RT）的概念将纯函数形式化。这是一个*表达式*的性质，而不仅仅是函数的性质。我们出于讨论的目的，考虑任何一个程序中的一段可以产生结果的表达式，好比任何你可以输入到scala解释器并获得结果的东西。例如，2 + 3是一个表达式，是纯函数+应用在值2和3上（这也是表达式）。无副作用。这个表达式的每次的运行结果都是5。事实上，如果你在一个程序中看到2 + 3，你可以简单地把它替换为5，它绝不会改变你的程序。

这就是所谓表达式的引用透明------在任何程序中，表达式可以被它的结果替换而不会改变程序的含义。所以我们说，假定输入是引用透明的，那么只要函数体是引用透明的，那么这个函数就是*纯函数*。

>工具栏：引用透明和纯函数
>如果对于所有程序p，所有在p中出现的表达式e，都可以用它的运行结果替换，并且不会给p带来可见的影响，那么这个表达式e就是引用透明的。如果函数f(x)对于所有引用透明的输入x，执行结果都是引用透明的，那么这个函数是*纯函数* [^footnote1]。

  [^footnote1]: 这个定义有些微妙之处，我们之后会在书中精炼一下。查阅章节笔记可以找到关于这个问题的更多讨论。


1.3 函数与非函数的区别：一个例子
----

引用透明开启了一种程序运行的推导模式称为*替代模型*（substitution model）。当表达式是引用透明的，我们可以想象，进行计算时很像我们解决一个代数方程的过程。我们充分展开表达式的每一部分，替换所有的变量，然后把它化简为最简单的形式。在每一个步骤中，我们都是把表达式用计算结果替换；我们说，进行计算的过程实际上就是*等价变换*（substituting equals for equals）。换句话说，RT使程序可以进行*等式推理*（equational reasoning）。这种风格的推理是*非常*自然的，实际上你在理解程序的时候一直使用它，即便是那些“非函数式”语言写的程序。

让我们来看两个例子------1.所有表达式都是RT的，可以使用替代模型推倒的例子。2.有些表达式无法使用替代模型。这并不复杂，我们只是想告诉你，我们介绍的这个概念实际上是你早已在某些层面上十分熟悉的事物。我们尝试在REPL中敲入以下代码： [^footnote2]


 [^footnote2]: 在java和scala中，字符串是不可变的。加入你想"修改"一个字符串，你必须创建它的一个拷贝。


	scala> val x = "Hello, World"
	x: java.lang.String = Hello, World
	
	scala> val r1 = x.reverse
	r1: String = dlroW ,olleH
	
	scala> val r2 = x.reverse
	r2: String = dlroW ,olleH

假设我们用x引用的表达式（即"Hello, World"）替换了所有x变量，如下所示：

	scala> val r1 = "Hello, World".reverse
	r1: String = dlroW ,olleH
	
	val r2 = "Hello, World".reverse
	r2: String = dlroW ,olleH

这种转化并不影响结果。r1和r2的值相同，所以x是引用透明的。更重要的是，r1和r2都是引用透明的，所以如果他们出现在一个更庞大的程序中时，依次使用他们的值来替换对程序没有任何影响。

现在让我们看一个*不是*引用透明的函数。例如scala.collection.mutable.StringBuilder类的append函数。这个函数可以操作StringBuilder，当调用append函数之后前一个状态的StringBuilder会被销毁。让我们来试一下：

	scala> val x = new StringBuilder("Hello")
	x: java.lang.StringBuilder = Hello
	
	scala> val y = x.append(", World")
	y: java.lang.StringBuilder = Hello, World
	
	scala> val r1 = y.toString
	r1: java.lang.String = Hello, World
	
	scala> val r2 = y.toString
	r2: java.lang.String = Hello, World

好的。接下来我们看看副作用是如何打破RT的。假设我们像之前一样，在所有出现y的地方使用y引用的表达式替换：

	scala> val x = new StringBuilder("Hello")
	x: java.lang.StringBuilder = Hello
	
	scala> val r1 = x.append(", World").toString
	r1: java.lang.String = Hello, World
	
	scala> val r2 = x.append(", World").toString
	r2: java.lang.String = Hello, World, World


经过这次转换后，程序出现了不同的结果。因此我们得出结论，StringBuilder.append*不是*纯函数。这次转换貌似r1和r2是一样的表达式，他们实际上引用了两个不同的StringBuilder值。在r2调用x.append时，实际上r1已经改变了x引用的对象。如果这一现象很难理解的话，那是因为它确实很难理解。副作用使程序行为的推理变得更加困难。

相反，替代模型推导起来更简单，运行的影响纯粹是本地的（影响只有表达式被执行这一部分），而且我们不需要心算一系列的状态变更来来理解一段代码。代码理解仅仅需要*局部推导*（local reasoning）。即使你没有使用“替代模式”，在你思考你的代码时也肯定会使用这种模式。 [^footnote3]

 [^footnote3]：在实践中，程序员不用花时间机械地应用替代模型，来确定代码是否是纯函数的------代码是否是纯函数的通常是相当明显的。

1.4为什么用函数式编程
----

我们说，运用FP会给我们更好的模块化。为什么这么说？虽然我们会在本书中做出详尽的解释，不过我们可以在这里给出一些初步的见解。

一个模块化的程序由它的各个组件组成，这些组件可以理解和独立的重用，这使得整个程序的含义只取决于各个组件的含义、以及是用什么规则把它们组织起来；也就是说，他们是*可组合的*（composable）。一个纯函数是模块化的和可组合的，因为它把计算逻辑本身和“结果如何处理”以及“如何获取输入”隔离开了；它就是一个黑盒。输入是只能通过一种方式获得：把参数传给函数。输出的结果是简单的计算并返回。通过把每一个问题隔离开来，计算的逻辑变得更容易被重用；我们可以随意重用这些逻辑，而不必担心的计算结果产生的副作用，或是在任何上下文中给输入参数带来的副作用。在函数执行前后，我们也不需要想着去跟踪所有的可能发生的状态改变，来理解我们的函数到底是干什么用的；我们只需看看函数的定义，在函数体内把形参换为实参，就可以理解这个函数。

让我们看一个案例是如何把代码转化为纯函数有助于重用的。这是一个简单的人造的例子，只是为了说明。假设我们正在写一个电脑游戏，并且需要做下面这件事情：

*如果玩家1的得分大于玩家2，则通知玩家1赢了，否则通知玩家2赢了。*

我们也许会这么写：

	case class Player(name: String, score: Int) //1
	def printWinner(p: Player): Unit = //2
	  println(p.name + " is the winner!")
	def declareWinner(p1: Player, p2: Player): Unit = //3
	  if (p1.score > p2.score) printWinner(p1)
	  else printWinner(p2)

 1. 定义了一个类Player包含两个属性：name:String， score:Int
 2. 把胜利者的名字打印在控制台中
 3. 传入两个玩家，对比他们的分数，宣布胜者

这里声明了一个简单的数据类型的Player，它有两个属性：String类型的name，Int类型的score。方法declareWinner根据两个Player，对比他们的得分，得分高者为胜者。printWinner方法打印胜者的名字到控制台。这个方法的返回类型是Unit，表示方法不返回一个有意义的结果，却造成了副作用。

我们在REPL中测试一下：

	￼scala> val sue = Player("Sue", 7)
	sue: Player = Player(Sue, 7)

	scala> val bob = Player("Bob", 8)
	bob: Player = Player(Bob, 8)
	
	scala> winner(sue, bob)
	Bob is the winner!

这段代码反映了之前我们讨论的问题，它把逻辑分支和展示结果耦合在一起，这使得重用逻辑分支变得困难重重。我们考虑重用declareWinner方法在n个选手中而不仅仅是两个来计算和显示唯一的胜者。在这种情况下，比较的逻辑很简单，我们可以直接嵌入它，但之后我们产生了重复的逻辑------当进行游戏测试时显示我们的游戏不公平的支持某一个玩家时，我们必须改变逻辑确定的赢家呢？我们必不得不修改两处代码。如果我们要使用相同的逻辑来排序之前玩家的历史记录来展示最高得分列表呢？

假设我们重构的代码如下：

	def winner(p1: Player, p2: Player): Player = //1
	  if (p1.score > p2.score) p1 else p2
	def declareWinner(p1: Player, p2: Player): Unit =
	  printWinner(winner(p1, p2))

 1. 这是一个纯函数，接收两个玩家，返回那个得分最高的玩家

这个版本将计算结果和结果展示的逻辑分离。在winner函数中计算胜者的代码是引用透明的，而不纯的那部分------显示结果------是在printWinner中保持独立。我们现在可以重用的winner的逻辑来计算的玩家名单中的胜者：

	val players = List(Player("Sue", 7), //1
                   Player("Bob", 8),
                   Player("Joe", 4))
	val p = players.reduceLeft(winner) //2
	printWinner(p) //3

 1. 构造一个玩家列表
 2. 化简这个列表，得分最高为胜者
 3. 在控制台中打印胜者的名字

在这个例子中，reduceLeft是标准Scala库中List的函数。该表达式将比较列表中所有玩家，并返回一个最高的得分的玩家。注意，我们实际上是通过把winner函数传给reduceLeft函数好像它就是个普通值一样。之后我们会花跟多章节讲解关于把函数作为另一个函数的参数这种使用方式，但现在我们只需要知道，因为winner是纯函数，我们可以重用它，并将它与其他函数以某种我们不曾使用过的方式结合。特别值得注意的是，如果我们把展示功能和计算胜者功能耦合在一起时，winner函数是无法使用这种用法的。

这只是一个简单的例子，意在说明，我们在这里做的一系列的重构也许是你以前做过很多次。有人说，函数式编程，至少在一些小例子中，只是正常的把关注和“良好的软件工程”分离开而已。

在这本书中我们将把FP的思想一直带到它的逻辑终端，并将在那些FP看似不太适用的场景中应用。我们将会学到，任何有副作用的函数都可以拆分为一个纯函数为核心，和一对有副作用的函数，一个在输入端，一个在输出端。这就是我们在把纯函数的winner从我们旧的winner函数中分离出来所做的。重复如此操作，我们可以把副作用推到程序的外围。函数式程序员经常讲的，用一个纯函数核心和薄薄的副作用处理层来构建程序。贯穿整本书，我们都会一再回到这个原则上来。

1.5总结
----

在这一章中，我们介绍了函数式编程和解释什么是FP以及为什么要采用它。在后面的章节中，我们介绍一些基础知识------如何用FP写循环？如何实现数据结构？如何处理错误和异常？我们需要学习如何使用low-level的FP语法来处理这些问题，并感到舒适。我们将在这一认知的基础上，探讨在2和3部分的函数式设计技巧。