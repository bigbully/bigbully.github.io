---
layout: post
title: 函数式编程scala第一章
description: 
category: scala
---

什么是函数式编程
===

1.1函数式编程的基本前提
---

函数式编程（FP）建立在一个简单的但是影响深远的前提下：我们构建我们的程序只使用*纯粹的函数*（pure functions）。换句话说，没有*副作用*的函数（side effects）。这到底是什么意思？下列任何一种表现方式都会带来副作用：

 - 给变量重新赋值
 - 适当的修改某种数据结构
 - 在一个对象上设置属性
 - 抛出一个异常或是因为错误而中断
 - 在控制台打印信息或是从用户输入读取信息
 - 读写文件
 - 在屏幕上画图

试想一下不使用上述任何一种能力的如何去编程吧。这可能有点难想象。这能编出任何有用的程序吗？假如你不能给变量重新赋值，如何写一个简单的循环程序？如何使用那些会改变的数据？或是如何处理错误而不抛出异常？我们如何进行像在屏幕上画图或是从文件中读取这样的IO操作？

答案就是我们仍然可以写出同样的程序，这些程序可以做一切上面提到的事情，甚至更多，而不引入任何副作用。函数式编程限制了我们*如何*去写程序，而不是能写出*什么样*的程序。而且接受这种限制带来了巨大的优势是因为我们使用了纯粹的函数进行编程带来的程序*模块化*的提升。因为模块化，纯粹的函数更容易被测试，被重用，被并行化，被泛化，被推论。

但收获这些优势需要我们重新审视编程行为，从最简单的任务开始做起，一步一步向上攀登。在很多场景之下，我们会发现许多砍死不得不产生副作用的程序完全可以用纯粹的函数代替。其他一些场景，我们发现可以使用一些方式构建的代码即便有副作用存在，但是并不会被*察觉到*（比如，我们可以改变那些声明于函数体内的数据，只要我们能保证这些数据不会被外部引用）。尽管如此，FP在程序组织方面产生了激进的提升，这种提升从最简单的循环，到高级程序架构。FP的风格与众不同，但是非常优美，并且很接近于我们希望你来欣赏的哪种编程方式。

在这本书中，你将学习的FP的概念和原理适用于各个层次的编程。我们在本章将从解释纯粹的函数是什么和它不是什么开始 ，我们也尝试给你一个想法，为什么纯粹的结果会更有利于模块化和代码重用。

1.2（纯粹的）函数到底是什么
---
一个函数，输入是A类型，输出是B类型（用scala表示就是：A => B），是把每一个A类型的值a计算出唯一的B类型的值b，这种b仅仅是由a来决定的。

例如，一个函数 intToString 的类型 Int => String， 会把每一个整数转化成对应的字符串。因此，如果它确实是一个*函数*，它只做这一件事情。

换句话说，一个函数除了基于输入计算出给定的结果之外，没有在执行过程中能观察到的其他影响；我们就说它是没有副作用的。我们有时会将这种函数称为*纯粹的*函数使之更加明确。其实你早就已经知道纯粹的函数了。考虑整数的加法函数（+）。它接收整数返回一个整数。对于任何两个给定的整数，它将*始终返回相同的整数值*。另一个例子是在Java，scala以及很多其他的编程语言中获得字符串长度的函数，对于任何给定的字符串，每次调用函数都返回相同的长度。

我们可以通过使用*引用透明*的概念将纯函数形式化。这是一个*表达式*的性质，而不仅仅是函数的性质。出于我们讨论的目的，考虑任何一个程序中的一段可以产生结果的表达式，好比任何你可以输入到scala解释器并获得结果的表达式。例如，2 + 3是一个表达式，是纯函数+应用在值2和3上（这也是表达式）。这没有副作用。这个表达式的每次的运行结果都是5。事实上，如果你在一个程序中看到2 + 3，你可以简单地把它替换为5，它绝不会改变你的程序。

这就是所谓表达式的引用透明------在任何程序中，表达式可以被它的结果替换而不会改变程序的意义。所以我们说，假定输入是引用透明的，那么只要函数体是引用透明的，那么这个函数就是*纯函数*。

>工具栏 **引用透明和纯函数**
>如果对于所有程序p，所有在p中出现的表达式e，都可以通过它的运行结果替换，并且不会给p带来可见的影响，那么这个表达式e就是引用透明的。如果函数f(x)对于所有引用透明的输入x，执行结果都是引用透明的，那么这个函数是*纯函数* [^footnote1]。

  [^footnote1]: 这个定义有些微妙之处，我们之后会在书中精炼一下。查阅章节笔记可以找到关于这个问题的更多讨论。


1.3 函数与非函数的区别：一个例子
----

引用透明开启了一种程序运行的推倒模式称为*替代模型*（substitution model）。当表达式是引用透明的，我们可以想象，进行计算很像我们解决一个代数方程的过程。我们充分展开表达式的每一部分，替换所有的变量，然后把它化简为最简单的形式。在每一个步骤中，我们都是把表达式用计算结果替换；我们说，进行计算的过程实际上就是*等价变换*（substituting equals for equals）。换句话说，RT使程序可以进行*等式推理*（equational reasoning）。这种风格的推理是非常自然的，实际上你在理解程序的时候一直使用它，即便是那些“非函数式”语言写的程序。

让我们来看两个例子------1.所有表达式都是RT的，可以使用替代模型推倒的例子。2.有些表达式无法使用替代模型。这并不复杂，我们只是想告诉你，我们介绍的这个概念实际上是你早已在某些层面上十分熟悉的事物。我们尝试在REPL中敲入以下代码： [^footnote2]


 [^footnote2]: 在java和scala中，字符串是不可变的。加入你想"修改"一个字符串，你必须创建它的一个拷贝。


	scala> val x = "Hello, World"
	x: java.lang.String = Hello, World
	
	scala> val r1 = x.reverse
	r1: String = dlroW ,olleH
	
	scala> val r2 = x.reverse
	r2: String = dlroW ,olleH

假设我们用x引用的表达式（即"Hello, World"）替换了所有x变量，如下所示：

	scala> val r1 = "Hello, World".reverse
	r1: String = dlroW ,olleH
	
	val r2 = "Hello, World".reverse
	r2: String = dlroW ,olleH

这种转化并不影响结果。r1和r2的值相同，所以X是引用透明的。更重要的是，r1和r2都是引用透明的，所以如果他们出现在一个更庞大的程序中时，依次使用他们的值来替换对程序没有任何影响。

现在让我们看一个*不是*引用透明的函数。例如scala.collection.mutable.stringbuilder类的append函数。这个函数可以操作StringBuilder，当调用append函数之后前一个状态的StringBuilder会被销毁。让我们来试一下：

	scala> val x = new StringBuilder("Hello")
	x: java.lang.StringBuilder = Hello
	
	scala> val y = x.append(", World")
	y: java.lang.StringBuilder = Hello, World
	
	scala> val r1 = y.toString
	r1: java.lang.String = Hello, World
	
	scala> val r2 = y.toString
	r2: java.lang.String = Hello, World

好的。接下来我们看看副作用是如何打破RT的。假设我们像之前一样，在所有出现y的地方使用y引用的表达式替换：

	scala> val x = new StringBuilder("Hello")
	x: java.lang.StringBuilder = Hello
	
	scala> val r1 = x.append(", World").toString
	r1: java.lang.String = Hello, World
	
	scala> val r2 = x.append(", World").toString
	r2: java.lang.String = Hello, World, World