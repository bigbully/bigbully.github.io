---
layout: post
title: 函数式编程scala第二章
description: 
category: scala
---

Getting started v1
===

2.1介绍
---
既然我们已经承诺使用纯函数，一个问题自然就来了：我们如何编写，即使是最简单的程序呢？大多数人都习惯于将程序作为一系列的命令，按顺序执行，每一个命令都带来相应的影响。在这一章中我们将学习如何用Scala语言写由纯函数组成的程序。

本章的主要目标读者是那些Scala初学者，或是函数式编程的初学者，或是两者皆为初学。如同学习外语一样，沉浸其中是一种非常有效的方法，所以我们会先看一个小而全的Scala程序。如果你没有Scala编程的经验，你别期待一看就能看懂代码。因此，我们将整个程序分解为多个部分，来看看它是什么。

我们会看到如何使用高阶函数。这些函数是以其他函数作为参数，或把一个函数作为其返回值。如果你写过很多代码，使用的语言并不能把函数当做参数或是返回值，那这个问题可能很难以理解（brain-bending）。记住，这不是关键，即便不管它，你也可以把本章讲的每一个概念记在心里，或是解决每一道习题。事实上，你可能会发现，现在先跳过整个部分，当你有更多经验之后再回来阅读，会简单的多。

2.2一个scala的程序
----
下面是一个完整的scala程序。

	// A comment!
	/* Another comment */
	/** A documentation comment */
	object MyModule {

	  def abs(n: Int): Int =
	    if (n < 0) -n
	    else n

	  private def formatAbs(x: Int) = {
	    val msg = "The absolute value of %d is %d"
	    msg.format(x, abs(x))
	  }

	  def main(args: Array[String]): Unit =
	    println(formatAbs(-42))

	  }

我们声明了一个对象（也被称为“模块”）命名的MyModule。对象是一个简便的让我们放代码的地方，和一个供我们引用的名字。关键词object创建一个新的单例类型，即MyModule是这种类型唯一的值（或"居民"）。我们把代码放在对象内部的大括号中。我们将讨论对象，模块，和命名空间的更多的细节。现在，让我们来看看这个特定的对象。

myModule对象有三个方法：abs，formatAbs，main。每一种方法是通过def关键字定义，跟着方法的名称，以及括号内的参数。在这种情况下，所有三种方法都只接收一个参数。如果有更多的参数，它们会用逗号隔开。紧跟着参数列表的右括号之后，有一个可选的返回值类型声明。

方法体置于等号（=）之后。我们有时会提到一个方法声明的部分，即在等号之前的部分，称之为左端（left-hand side）或方法签名（signature），以及在等号之后的部分，我们有时会称之为右端（right-hand side）或方法定义（definition）。注意，方法没有一个明确的return关键字。一个方法的返回值是就是方法右端的值。

现在让我们一个一个浏览这些方法。方法abs表示一个纯函数，它接收一个整数，并返回它的绝对值 ：[^footnote1]

 [^footnote1]:聪明的读者可能会注意到，这个方法定义并不适用于Integer.minvalue，即最小的负32位的整数，它没有相应的正整数。在这里我们会忽略这个细节。

	def abs(n: Int): Int = //1
		if (n < 0) -n
		else n //2

 1. 方法abs接收一个Int类型参数，这里使用 n : Int 来声明
 2. 函数定义是一个Scala表达式：使用内置的if语法，当n小于0时返回-n

formatAbs方法表示另一个纯函数：

	private def formatAbs(x: Int) = {
	  val msg = "The absolute value of %d is %d."
	  msg.format(x, abs(x)) //1
	}

 1. 这个String的format方法来自标准库。我们在msg对象中调用这个方法，传入x和abs(x)。结果返回一个新的String，把%d出现的地方依次使用x和abs(x)替换。你可以在下面的侧边栏中看到对于String的补充说明。

该方法声明为私有的，这意味着它不能从MyModule这个对象外部被调用。这个函数接收一个Int类型返回一个String类型，但请注意返回值类型并没有声明。Scala通常可以推断出方法的返回类型，所以他们可以省略，但如果你希望别人使用你定义的这个方法，那么声明方法的返回类型会更好。formatAbs方法是私有的，所以我们可以省略这种类型注释。

该方法体包含多条语句，所以我们把它们放在大括号内。一对大括号内的语句我们称之为*代码块*。新的一行或是被分号分隔都被认为是一条语句。上文使用的是新的一行来分隔我们的语句。

块中第一条语句使用val关键字声明了一个String类型。val是不可变的变量，所以formatAbs方法体内的msg总是指向同一个String的值。如果你尝试给msg在同一个上下文中重新赋值，Scala编译器将会发出抱怨。

记住，一个方法只是简单地返回它右端代码块中的值。一个在大括号中的多语句的代码块的值等于最后一条语句的值。所以，formatAbs方法的结果就是msg.format(x, abs(x))的值。

>侧边栏：String在Scala中的补充
>我们可以使用String的补充方法（[文档](http://docs.scala-lang.org/overviews/core/string-interpolation.html)）编写我们的formatAbs函数，而不是使用String的format方法。补充之后的String可以引用上下文中声明了的值。String补充对象需要在第一个双引号之前加s，比如s"the absolute value of $x is ${abs(x)}" 。你可以通过上面的链接在文档中查看详细信息。

最终，我们的main方法只是一个外壳，调用了纯函数的核心，并在控制台上打印这个结果。

	def main(args: Array[String]): Unit =
	  println(formatAbs(-42))

main方法很特殊，因为当你运行程序时，Scala会去寻找带有特殊方法签名的main方法。它必须以一个String数组作为其参数，并且它的返回类型必须为Unit。args数组将包含在命令行传给程序的参数。Unit的返回类型表示，此方法不返回任何有意义的值。Unit类型的实例只有一个，而且它没有内部结构。它写作（），发音为“unit”。通常一个返回类型是Unit的方法意味着该方法具有副作用。但是，因为main方法本身只会被操作系统调用一次，而且绝不会在程序的任何地方被调用，所以它并不违反引用透明原则。

2.3运行我们的程序
-----

本节讨论用最简单的方式运行Scala程序，适合短小的例子。通常，你会使用sbt（一种Scala的构建工具 ）构建和运行你的代码，并且/或者使用像IntelliJ或Eclipse这样的IDE。你可以在GitHub中的本书源码项目中找到使用sbt构建的更多信息。当代码改变时，sbt足够聪明，可以尽可能少的重新编译代码。它也有一些其他好用的功能，不过我们不会在这里讨论。

不过最简单的方法来运行这个Scala程序（MyModule）是使用命令行，直接调用Scala编译器。我们将代码放在一个文件名为myModule.scala或类似的文件中，然后使用scalac编辑器把它编译成Java字节码：

	> scalac MyModule.scala

这将生成一些.class后缀的文件。这些文件包含编译后的可以在jvm中运行的代码。该代码可以使用Scala代码运行器运行：

	> scala MyModule
	The absolute value of -42 is 42.

实际上，先用scalac编译代码并不是完全必要的。一个像我们这里所写的简单程序，可以直接把Scala代码传递给Scala解释器运行：

	> scala MyModule.scala
	The absolute value of -42 is 42.

所以使用Scala脚本变得更加便利。代码运行起会在myModule.scala中寻找任何带有main方法及相应的方法签名的对象，然后调用它。

最后，另一种方法是启动scala解释器的交互模式，通常被称为"阅读执行打印循环"或REPL（发音为"repple"和"apple"类似），并从那里加载文件（你的控制台有可能和这里显示的略有不同）：

	> scala
	Welcome to Scala.
	Type in expressions to have them evaluated.
	Type :help for more information.
	
	scala> :load MyModule.scala
	Loading MyModule.scala...
	defined module MyModule
	
	scala> MyModule.main(Array()) //1
	The absolute value of -42 is 42.

 1. main方法接收一个array作为参数，这里我们简单的传入一个空array

也可以简单的把代码复制和粘贴到REPL。它也有一个粘贴模式（使用:paste开启）专门设计为粘贴代码。尽可能熟悉一下REPL及其特点吧。


2.4模块（modules），对象（objects）和命名空间（namespaces）
----

注意，上文提到的main方法，如果我们想引用它，需要使用MyModule.main，因为main是定义在MyModule这个对象（object）中的。除了一些生僻的技术用例，在Scala中的每个值都是一个所谓的"对象"。对象的主要目的是给它的成员一个名称空间（namespace），有时也称为一个模块（module）。一个对象可能有零个或多个成员。成员可以是使用关键字def声明的方法，也可以是另一个使用val或object声明的对象。对象也可以有其他类型的成员，我们现在先忽略。

我们使用典型的面向对象的"点"来间接引用对象的成员，这是一种命名空间（即名称所指的对象）后面接一个点，之后是成员的名字。例如，用MyModule.abs(42)来调用MyModule对象的方法abs。用42.toString来调用对象42的toString方法。对象内部的成员彼此引用时是无限制的（unqualified），即无需加前缀的，但如果需要的话，他们使用一种特殊m封闭名字"this"来只带对象自身。

值得注意的是，即使是2 + 1这样的表达式也只是调用对象的一个成员。在这种情况下，调用的是对象2的+方法。这是真的只是2.+(1)的一个语法糖而已。当我们调用只接收一个参数的方法时，我们一般省略点和圆括号。例如调用myModule.abs(42)我们可以写成 myModule abs 42，得到同样的结果。

我们可以把对象的成员导入到当前域中，它允许我们不加前缀来调用：

	scala> import MyModule.abs
	import MyModule.abs

	scala> abs(-42)
	res0: 42


我们可以把所有对象所有的（非私有）成员使用下划线语法全部导入：import  MyModule._

>工具栏：包
>在Scala中，就有一种语言构造叫*包*（package），它是一种没有对象的命名空间。包和模块之间的区别是，一个包中不能含有val或def的成员，而且不能像对象一样被传来传去。
>例如，我们可以在Scala的源文件中声明一个包：

	package mypackage
	
	object MyModule {
	  ...
	}

>之后我们可以引用mypackage.MyModule作为一个有限制的名字，或者我们可以import mypackage._ 这样就可以无限制的引用myModule了。然而，我们不能用f(mypackage)这样的语法，把包当做参数传给函数f，因为包不是在Scala中一等公民。

2.5函数对象：把函数作为参数传给函数
---

在Scala中，函数也是对象。它们可以像其他值一样传递、赋值给变量，在数据结构中存储，等等。当编写纯函数程序时，我们很自然的想接收函数作为其他函数的参数。我们来看一些很简单的例子来说明这个思想。在本章中，我们将看到这种能力是多么有用，以及它如何渗透我们的编程风格中去的。但我们首先假设我们想让我们的程序打印出一个数字的绝对值和另一个数的阶乘。下面是这样一个程序的运行结果：

	
	The absolute value of -42 is 42
	The factorial of 7 is 5040

首先，我们来写一个阶乘，这正好是我们第一个不使用可变变量来写一个循环的例子[^footnote2]：

	def factorial(n: Int): Int = { //1
	  def go(n: Int, acc: Int): Int = //2
	    if (n <= 0) acc
	    else go(n-1, n*acc)
	  go(n, 1) 
	}

 1. Int是Scala中有个基本类型，代表32位整数
 2. 这是一个内部或本地方法

[^footnote2]:我们也可以用一个普通的While循环和可变变量来写。看一下这一章的代码示例。


我们在Scala编写循环的方法是用一个递归函数，按惯例，通常被称为go（或是loop），我们通常会定义局部函数（不像Java，Scala中我们可以在任何一个代码块中定义函数，包括在另一个函数体内定义）。go接收的参数是循环的状态（在本例中，其余的值n，和目前的积累因子，acc）。想要前进到下一次迭代，我们只是使用新的循环状态来调用递归函数（在这里，go(n-1，n*acc)），想要退出循环，我们就不再调用递归，而是返回一个值（这里，当n <= 0时我们返回acc的值）。Scala检测这种自递归函数会把它编译成和While循环同样的字节码，这种递归调用出现在函数尾部的位置。看看这个技术细节的工具栏吧，不过基本的思想是，当递归调用后不再做其他额外的事情时，会进行这种优化（称为尾调用优化）[^footnote3]。

[^footnote3]: 这种尾调用优化（TCO）实际上名字取得并不合适。“优化”通常意味着一些不必要的性能改善，但当我们使用尾调用写循环，我们通常依赖于他们被编译为迭代循环，这样不会为每一次迭代消耗调用堆的帧（这会在输入很大时导致StackOverflowError）。

>工具栏：Scala中的尾部调用
>如果调用方除了返回递归调用之外，没有做其他任何事情，则称之为“尾位置”（tail position）。例如，递归调用go(n-1, n*acc)就处在尾位置，因为调用方仅仅返回该递归调用的值。如果，相反，我们返回1 + go(n-1, n*acc)，go函数的调用就不再处于尾位置，因为调用方在go返回它的结果之后仍然有工作要做（即，+1）。同理，如f(go(n-1, n*acc))，f是另一个方法，go的递归调用仍然不处于尾位置。如果所有的递归调用的函数都处于尾位置，Scala会把递归调用编译成迭代循环，这样不会为每一次迭代时消耗调用堆的帧。如果我们期望"尾递归优化"发生在我们写的递归函数上，我们可以使用一个标注（[更多信息可以来这里查看](http://stackoverflow.com/questions/3114142/what-is-the-scala-annotation-to-ensure-a-tail-recursive-function-is-optimized)）来告诉Scala编译器这个预期（关于这方面的更多信息），所以如果这个递归函数确实不能被优化，Scala编译器会返回给我们一个编译错误。这里的语法是这样的：
	
	def factorial(n: Int): Int = {
	  @annotation.tailrec
	  def go(n: Int, acc: Int): Int =
		if (n <= 0) acc
	    else go(n-1, n*acc)
	  go(n, 1)
	}


>我们不会花很多笔墨在本书中介绍标注，不过我们会大量的使用@annotation.tailrec。


习题1（可选）：写一个函数来得到第n个斐波那契数。前两个Fibonacci数分别为0和1，下一个数字是前两个数字相加。你的函数需要使用尾递归[^footnote4]。

	 def fib(n: Int): Int

现在我们有了阶乘函数（factorial）,现在让我们在之前的程序上接着进行修改：

[^footnote4]:注意，求第n个斐波那契数有一种[闭式解](https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression)。使用这种解法可算是作弊；这里是让你练习用尾递归来写循环的。

formatAbs和formatFactorial这两个函数几乎是完全相同的。我们也可以把这两个函数抽象成一个函数：formatResult，它接收另一个函数作为参数：

	def formatResult(name: String, n: Int, f: Int => Int) = {
	  val msg = "The %s of %d is %d."
	  msg.format(n, f(n))
	}
	
	def main(args: Array[String]): Unit = {
	  println(formatResult("absolute value", -42, abs))
	  println(formatResult("factorial", 7, factorial))
	}

这里有一些新东西。首先，我们formatResult函数接收多个参数。一个函数如果有多个参数，我们用逗号分隔每个参数。其次，我们的formatResult函数现在需要另一个函数，我们称之为f（这是FP中常见的命名约定，详见工具栏）。一个函数作为另一函数的参数被称为*高阶函数*（higher-order function，HOF）。像其他参数一样，我们给出了一个类型：int => int，这表明f接收一个Int返回也是Int（如果函数的类型是接收一个Int和String并返回一个Int会写成(int, string) => Int）。

接着，注意我们调用f使用同样的语法，如同调用abs(x)或factorial(n)。最后，注意，我们可以把函数abs和formatResult的引用传给函数formatResult。abs接收一个Int返回Int，与f要求的类型 int => int匹配。同样，factorial接收一个Int返回Int，也与f要求的类型 int => int匹配。

>工具栏：FP中的变量命名规则
>HOF接收的函数参数遵从一个共同的约定，使用f，g，h作为参数名。在FP中，我们倾向于使用一个字母或非常短的变量名，尤其所有信息都已经可以由参数的类型表达清楚的时候。因为FP中的函数通常都很短小，许多函数式程序员觉得这会使代码更易于阅读，因为它使代码的结构更明了。我们将在这本书继续介绍类似的约定。

这个例子可能不是很令人兴奋，但同样的原则适用于更大的例子，等我们遇到重复代码时，我们可以用作为一等公民的函数来重构。在这本书中，我们会看到更多这样的例子。

2.5.1匿名函数
---

在函数式编程中函数会经常被传来传去，因此会有一种轻量级的方法来声明一个函数：本地的，匿名的函数。Scala提供了相应的语法来声明这种没有名字或称之为*匿名函数*。（通常也被称为字面函数，lambda函数，Lambda表达式，或是lambda。[^footnote5]）

[^footnote5]:lambda这个名字来源于[lambda演算](http://en.wikipedia.org/wiki/Lambda_calculus)，计算理论中的又一个理论基础


我们来看一些匿名函数的例子：

	def main(args: Array[String]): Unit = {
	  println(formatResult("absolute value", -42, abs))
	  println(formatResult("factorial", 7, factorial))
	  println(formatResult("increment", 7, (x: Int) => x + 1))
	  println(formatResult("increment2", 7, (x) => x + 1))
	  println(formatResult("increment3", 7, x => x + 1))
	  println(formatResult("increment4", 7, _ + 1))
	  println(formatResult("increment5", 7, x => { val r = x + 1; r }))
	}


	The absolute value of -42 is 42
	The factorial of 7 is 5040
	The increment of 7 is 8
	The increment2 of 7 is 8
	The increment3 of 7 is 8
	The increment4 of 7 is 8
	The increment5 of 7 is 8

在这段代码中，(x:Int) => x + 1，(x) => x + 1，x => x + 1 ，和_ + 1都是增量方法的不同写法，它的类型是Int => Int。这个符号，lambda表达式的左端为((x:Int)，(x)，x）和右端（x + 1，{val result = x + 1;result}），用箭分离，=>。左端按顺序声明了参数（(x, y) => x + y是有两个参数的匿名函数的例子），右端，是函数体，表示函数会返回什么。函数体当然可以推倒出参数[^footnote6]。

[^footnote6]:请注意，在这种情况下，Scala知道formatResult期望接收Int => Int，我们可以注明x的类型；在其他情况下，Scala可能不知道参数的类型，将迫使你注明为(x:Int) => …


我们可以声明一个值，他的类型如val f = (x:Int) => x + 1，但在这里我们没有声明一个局部变量的函数，虽然这在FP中很常见的。对于最后的形式 _ + 1，有时称为函数字面量的*下划线语法*，这里我们甚至懒得给函数的参数命名，使用下划线代表这个唯一的参数。用这个符号的时候，我们只能在方法体中使用引用这个参数一次。（如果我们在此使用下划线，它指的是函数的另一个参数[^footnote7]）

[^footnote7]:有各种各样的规则会影响下划线的使用范围，我们不会在这里讨论。详细说明你可以看一下[Scala语言规范，6.23节](http://www.scala-lang.org/docu/files/ScalaReference.pdf)。一般来说，如果你不得不思考一下下划线在这个表达式中会被如何解释的时候，那么最好就使用命名参数的语法，比如x => x + 1 。

>工具栏：函数是普通对象
>我们说过，函数和方法在Scala中不完全是一样的东西。当我们定义一个函数字面量时，实际上被定义了具有apply方法的一个对象。Scala对于这种方法有特殊的规则，使当一个有apply方法的对象被调用时，就好像你在对象自身就是方法。当我们定义一个函数字面量如：(a, b) => a < b， 实际上是创建了如下这个对象的语法糖：
	val lessThan = new Function2[Int, Int, Boolean] {
	  def apply(a: Int, b: Int) = a < b
	}
>lessThan的类型是Function2[Int,Int,Boolean]，通常写作(Int,Int) => Boolean。注意Function2接口（Scala中被称为“特质”）有唯一的方法apply。当我们使用lessThan(10, 20)来调用lessThan函数时，实际上是调用apply方法的语法糖：

	scala> val b = lessThan.apply(10, 20)
	b: Boolean = true
Function2只是一个Scala标准库（[API文档点这里](http://www.scala-lang.org/api/current/index.html#scala.Function2)）中的普通的特质（即接口），它代表接收两个参数的函数对象。Scala还提供了Function1，Function3等等，通过特质名称来区分他们接收多少个参数。因为函数是真的只是普通的Scala对象，所以我们说他们是一等公民。我们通常会使用“函数”来表示一等公民的函数或方法，这取决于上下文。


2.6多态函数：类型层面的抽象
到目前为止我们只定义的*单态*（monomorphic）函数。也就是说，函数只操作一种类型的数据。例如，abs和factorial就是具体接收Int类型的参数，以及高阶函数formatResult，它接收Int => Int类型的函数作为参数。通常我们会想写一些适用于任何类型的代码。这里有一个例子，使用二分法搜索的定义，专门用来在Array[Double]中寻找Double类型的值。Double是又一个Scala的基本类型，用来表示双精度的浮点数。Array[Double]代表Double类型的数组。

	def binarySearch(ds: Array[Double], key: Double): Int = {
	  @annotation.tailrec
	  def go(low: Int, mid: Int, high: Int): Int = {
	    if (low > high) -mid - 1
	    else {
	      val mid2 = (low + high) / 2
	      val d = ds(mid2) //1
	      if (d == key) mid2
	      else if (d > key) go(low, mid2, mid2-1)
	      else go(mid2 + 1, mid2, high)
		}
	  }
	  go(0, 0, ds.length - 1)
	}

 1. 我们根据index获取数组元素的语义与调用函数实际执行的是apply方法类似。

算法的细节在这里并不重要。最重要的是，使用二分法搜索，应用在从Array[Double]中查找Double值，从Array[Int]中查找Int值， 从Array[String]中查找String值，或是从Array[A]中查找A类型的值，代码几乎都是一样的。我们可以使用类型A来更普适的写这个二分法搜索的代码，只需要添加一个函数用于测试一个值是否大于另一个：

	def binarySearch[A](as: Array[A], key: A, gt: (A,A) => Boolean): Int = {
	  @annotation.tailrec
	  def go(low: Int, mid: Int, high: Int): Int = {
	    if (low > high) -mid - 1
	    else {
	      val mid2 = (low + high) / 2
	      val a = as(mid2)
		  val greater = gt(a, key)
	      if (!greater && !gt(key,a)) mid2
	      else if (greater) go(low, mid2, mid2-1)
	      else go(mid2 + 1, mid2, high)
		}
	  }
	  go(0, 0, as.length - 1)
	}

这是一个多态函数[^footnote8]的例子。我们对数组的*类型进行抽象*，并通过比较函数来搜索它。写一个多态的功能，我们引入一个逗号分隔的*类型参数*列表包含在[ ]内（在这里，只是单一的[A]），接在函数名称之后，当期示例中[A]接在函数名binarySearch之后。我们可以给类型参数起任何名字------ [ Foo, Bar, Baz]或[TheParameter, another_good_one]，都是有效类型参数声明------虽然按惯例，我们通常使用短的，一个字母的类型参数名称，如[A, B, C]。
	
[^footnote8]:我们使用的术语“多态”（polymorphism）与面向对象编程中的多态稍有不同，面向对象中通常意味着某种形式的子类型。在这个示例中没有接口或子类型。偶尔会看到一个术语的*参数多态性*（parametric polymorphism），在过去指代多态。


类型参数列表中引入的*类型变量*（或有时称作类型参数），可以在类型签名（type signature）中被引用（完全类似于变量被引入后如何在函数体内被引用）。在这里，类型参数A在三个地方被引用------搜索的key需要是A类型的，数组的值也必须是A类型的（因为它是一个Array[A]），以及gt函数必须接受两个A类型的参数（因为它的类型是 (A, A) => Boolean）。事实上，同一个类型参数在类型签名的所有三个地方被引用，表明三个参数的类型都必须是相同的，并且编译器将在我们调用binarySearch的任何地方强制检查。如果我们试图在Array[Int]中寻找String的值，我们将会得到一个类型不匹配错误[^footnote9]。

[^footnote9]:不幸的是，Scala使用了子类型意味着我们有时会遇到一些莫名其妙的编译错误，因为Scala会尝试查找一个通用的服类型作为类型参数A，就有可能找到Any类型，即所有类型的父类。

练习2：实现isSorted，检查一个Array[A]是否已经根据比较函数排序过了。

	def isSorted[A](as: Array[A], gt: (A,A) => Boolean): Boolean


>工具栏：Scala中的包装类型和特殊化
>在某些类型中多态函数通常会强制的把这些类型标识为*装箱过的*、非基本类型，这意味着它们被存储为一个指向堆上的值的指针。我们可以引导Scala编译器为每个基本类型产生一个函数的特殊版本，只需在类型参数上添加一个注释：

	def binarySearch[@specialized A](as: Array[A], key: A,
                                 gt: (A,A) => Boolean): Int

>这可能是更有效的，尽管其机制相当脆弱，因为当多态值被传给任何其他的多态函数或数据类型时，因为那些多态函数和数据类型不是特殊化过的，所以他们会被立即装箱。


正如你在编写isSorted时可能已经看到的，当实现了多态函数后可能的实现范围被显著减少了。如果一个函数的类型A是多态的，在A上唯一的操作就是通过参数传过来的那个函数，比如gt（或者是那些已经内置操作[^footnote10]）。在某些情况下，你会发现这个给定的多态类型的范围的可能性已经被限制到只有唯一的实现！

[^footnote10]:技术上讲，Scala中的所有值都可以比较相等性（使用"=="）,我们也可以计算他们的hashcode。不过这算是从Java集成下来的一点瑕疵。


让我们看一个例子，一个高阶函数实现局部应用（partial application）。这个函数，partial1，接收一个值和带两个参数的函数，返回结果是带一个参数的函数。这个名字来自于这个事实：这个函数并没有应用所有的参数，而是被应用了一部分。

	def partial1[A,B,C](a: A, f: (A,B) => C): B => C

练习3（难）：实现partial1，并写下它的具体用法。只有一个可以通过编译的实现。这里我们没有任何具体的类型，所以我们只能使用建立在类型签名上的本地“规则”来把事情粘合在一起。这里所需要的推理方式在函数式编程里是非常普遍的------我们只是简单地使用非常抽象的方式操作符号，类似于在解决代数方程时我们是如何推理的。


练习4（难）：让我们来看看另一个例子，克里化（currying），它将n个参数的一个参数的函数，转化成另一个只有一个参数的函数，这个函数返回第三个函数作为他的结果[^footnote11]。顺便再说一下，这里只有一种实现方式可以通过类型检查。

[^footnote11]:克里化以数学家Haskell Curry命名的，它发现了这个理论。这个理论其实被Moses Schoenfinkel更早独立发现，不过如果叫“schoenfinkelization”。。。所以最后就命名为克里化。

练习5（选做）：实现 uncurry， 这是对curry的翻转。注意因为 => 链接这右端，所以 A => (B => C) 可以写作 A => B => C。

	def uncurry[A,B,C](f: A => B => C): (A, B) => C

让我们看一个最后的例子，*函数组合*（function composition），它将一个函数的输出作为另一个函数的输入。再次强调，该功能的实现完全取决于它的类型签名。

练习6：实现高阶函数，它可以把两个函数组合起来。

	def compose[A,B,C](f: B => C, g: A => B): A => C

这是一个非常常见的需求，以至于Scala标准库在Function1中直接提供了这个方法。想要组合两个函数f和g，只需要简单的写作f compose g。它还提供了一个andThen方法。f andThen g和g compose f是一个作用。

	scala> val f = (x: Double) => math.Pi / 2 - x
	f: Double => Double = <function1>
	
	scala> val cos = f andThen math.sin
	cos: Double => Double = <function1>


有趣的是，像compose这样的函数并不关心它们是在操作由数百万行代码组成的函数，还是一行代码的函数。多态性，高阶函数往往最终被广泛适用，正是因为他们对不限定于任何特定的领域，只是在许多情况下，作为对共同模式的一个简单抽象。在这本书的过程中，我们会写下更多这样的函数，而在你编写这些函数用到的推理和思考风格，现在只是进行了一次初探。

2.7总结
-----


在这一章中我们学习了一些初步功能的编程概念，足够使用Scala来学习本书了。我们学会了如何定义简单的函数和程序，包括如何使用递归表示循环，然后介绍了高阶函数的思想，做了一些练习来学习如何用Scala写多态函数。我们看到了多态函数的实现往往有着显著的约束，这样的我们就可以简单的"参照类型"去正确的实现。我们在后面的章节中会看到更多这样的例子。

虽然我们还没有编写任何大型或复杂的程序，我们在这里讨论的原则是可扩展的，同样无论程序大小它都同样适用。

下一步我们将看看如何使用纯函数来处理数据。