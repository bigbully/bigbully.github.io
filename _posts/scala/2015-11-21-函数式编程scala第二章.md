---
layout: post
title: 函数式编程scala第二章
description: 
category: scala
---

Getting started
===

2.1介绍
---
既然我们已经承诺使用纯函数，一个问题自然就来了：我们如何编写，即使是最简单的程序呢？大多数人都习惯于将程序作为一系列的命令，按顺序执行，每一个命令都带来响应的影响。在这一章中我们将学习如何在Scala语言写由纯函数组成的程序。

本章的主要目的是为那些scala初学者，或是函数式编程的初学者，或是两者皆为初学。如同学习外语，沉浸是一种非常有效的方法，所以我们会先看一个小而全的Scala程序。如果你有Scala没有经验，你别期待一看就能看懂代码。因此，我们整个程序分解为多个部分，来看看它是什么。

我们会看到如何使用高阶函数。这些函数是以其他函数作为参数，并且可能把一个函数作为其返回值。如果你写过很多代码，使用的语言并不能把函数当做参数或是返回值，那这个问题可能很难以理解（brain-bending）。记住，这不是关键，即便不管它，你也可以把本章讲的每一个概念记在心里，或是解决每一道习题。事实上，你可能会发现，现在先跳过整个部分，当你有更多经验之后再回来看，会变得更简单。

2.2一个scala的程序
----
下面是一个完整的scala程序。

	￼// A comment!
	/* Another comment */
	/** A documentation comment */
	object MyModule {
	  def abs(n: Int): Int =
	    if (n < 0) -n
	    else n
	  private def formatAbs(x: Int) = {
	    val msg = "The absolute value of %d is %d"
	    msg.format(x, abs(x))
	  }
	  def main(args: Array[String]): Unit =
	    println(formatAbs(-42))
	  }

我们声明了一个对象（也被称为“模块”）命名的myModule。这是简单地给我们的一个放代码的地方，和一个供我们引用的名字。关键词object创建一个新的单例类型，即myModule是这种类型唯一的值（或"居民"）。我们把代码放在对象内部的大括号中。我们将讨论对象，模块，和命名空间的更多的细节。现在，让我们来看看这个特定的对象。

myModule对象有三个方法：abs，formatAbs，main。每一种方法是通过def关键字定义，跟着方法的名称，以及括号内的参数。在这种情况下，所有三种方法只接收一个参数。如果有更多的参数，它们会用逗号隔开。接着参数列表的右括号之后，有一个可选的返回值类型声明。

方法体在置于等号（=）之后。我们有时会提到一个方法声明的部分，即在等号之前的部分，称之为左端（left-hand side）或方法签名（signature），以及在等号之后的部分，我们有时会称之为右端（right-hand side）或方法定义（definition）。注意没有一个明确的return关键字。一个方法的返回值是就是方法右端的值。

现在我们一个一个过这些方法。方法abs表示一个纯函数，它接收一个整数，并返回它的绝对值 ：[^footnote1]

 [^footnote1]:聪明的读者可能会注意到，这个方法定义并不适用于Integer.minvalue，即最小的负32位的整数，它没有相应的正整数。在这我们会忽略这个细节。

	def abs(n: Int): Int = //1
		if (n < 0) -n
		else n //2

 1. 方法abs接收一个Int类型参数，这里使用 n : Int 来声明
 2. 函数定义是一个scala表达式：使用内置的if语法，当n小于0时返回-n

formatAbs方法表示另一个纯函数：

	private def formatAbs(x: Int) = {
	  val msg = "The absolute value of %d is %d."
	  msg.format(x, abs(x)) //1
	}

 1. 这个String的format方法来自标准库。我们在msg对象中调用这个方法，传入x和abs(x)。结果返回一个新的String，把%d出现的地方依次使用x和abs(x)替换。你可以在下面的工具栏中看到对于String补充的说明。

该方法声明为私有的，这意味着它不能从MyModlure这个对象外被调用。这个函数接受一个Int类型返回一个String类型，但请注意返回值类型并没有声明。Scala通常可以推断出方法的返回类型，所以他们可以省略，但如果你希望别人使用你定义的这个方法，那么声明方法的返回类型会更好。这种方法是私有的，所以我们可以省略这种类型注释。

该方法体包含多条语句，所以我们把它们放在大括号内。一对大括号内的语句我们称之为*代码块*。新的一行或是被分号分隔被认为是一条语句。上文使用的是新的一行来分隔我们的语句。

块中第一条语句使用val关键字声明了一个String类型。val是不可变的变量，所以formatAbs方法体内的msg总是指向同一个String的值。如果你尝试给msg在同一个上下文中重新赋值，Scala编译器将会发出抱怨。

记住，一个方法只是简单地返回它右端代码块中的值。一个在大括号中的多语句的代码块的值等于最后一条语句的值。所以，formatAbs方法的结果就是msg.format(x, abs(x))的值。

>工具栏：String在scala中的补充
>我们可以使用String补充方法（[文档](http://docs.scala-lang.org/overviews/core/string-interpolation.html)）编写我们的formatAbs函数，而不是使用String的format方法。补充了的String可以引用上下文中声明了的值。一个声明了的String对象有个在第一个双引号之前需要加s，比如s"the absolute value of $x is ${abs(x)}" 。你可以通过上面的链接在文档中查看详细信息。

最终，我们的main方法只是一个外壳，调用了纯函数的核心，并展现控制台上打印这个结果。

	def main(args: Array[String]): Unit =
	  println(formatAbs(-42)

main方法很特殊，因为当你运行程序时，Scala会去寻找带有特殊方法签名的main方法。它必须以一个String数组作为其参数，并且它的返回类型必须为Unit。args数组将包含在命令行传给程序的参数。Unit的返回类型表示，此方法不返回任何有意义的值。Unit类型的实例只有一个，而且它没有内部结构。它写作（），发音为“unit”。通常一个返回类型是Unit的方法意味着该方法具有副作用。但是，因为main方法本身只会被操作系统调用一次，而且绝不会在程序的任何地方被调用，所以它并不违反引用透明原则。

2.3运行我们的程序
-----

本节讨论用最简单的方式运行Scala程序尽，适合短小的例子。通常，你会使用sbt（一种Scala的构建工具 ）构建和运行你的代码，并且/或者使用像IntelliJ或Eclipse这样的 IDE。你可以在GitHub中的本书源码项目中找到使用sbt构建的更多信息。当代码改变时，sbt足够聪明，可以尽可能少重新编译代码。它也有一些其他好用的功能，不过我们不会在这里讨论。

但最简单的方法来运行这个Scala程序（myModule）是使用命令行，直接调用Scala编译器。我们将代码放在一个文件名为myModule.scala或类似的文件中，然后使用scalac编辑器把它编译成Java字节码：

	￼> scalac MyModule.scala

这将生成一些.class后缀的文件。这些文件包含编译后的可以在jvm中运行的代码。该代码可以使用Scala代码运行器运行：

	> scala MyModule
	The absolute value of -42 is 42.

实际上，先用scalac编译代码并不是完全必要的。一个像我们这里所写的简单程序，可以直接把Scala代码传递给Scala解释器运行：

	> scala MyModule.scala
	The absolute value of -42 is 42.

所以使用Scala脚本变得更加便利。代码运行起会在myModule.scala中寻找任何带有main方法及相应的方法签名的对象，然后调用它。

最后，另一种方法是启动scala解释器的交互模式，通常被称为"阅读执行打印循环"或REPL（发音为"repple"和"apple"类似），并从那里加载文件（你的控制台有可能和这里显示的略有不同）：

	> scala
	Welcome to Scala.
	Type in expressions to have them evaluated.
	Type :help for more information.
	
	scala> :load MyModule.scala
	Loading MyModule.scala...
	defined module MyModule
	
	scala> MyModule.main(Array()) //1
	The absolute value of -42 is 42.

 1. main方法接收一个array作为参数，这里我们简单的传入一个空array

也可以简单的把代码复制和粘贴到REPL。它也有一个粘贴模式（使用:paste开启）专门设计为粘贴代码。尽可能熟悉一下REPL及其特点吧。


2.4模块（modules），对象（objects）和命名空间（namespaces）
----

注意，上文提到的main方法，如果我们想引用它，需要使用MyModule.main，因为main是定义在MyModule这个对象（object）中的。除了一些生僻的技术用例，在Scala中的每个值都是一个所谓的"对象"。对象的主要目的是给它的成员一个名称空间（namespace），有时也称为一个模块（module）。一个对象可能有零个或多个成员。成员可以是使用关键字def声明的方法，也可以是另一个使用val或object声明的对象。对象也可以有其他类型的成员，我们现在先忽略。

我们使用典型的面向对象的"点"来间接引用对象的成员，这是一种命名空间（即名称所指的对象）后面接一个点，之后是成员的名字。例如，用MyModule.abs(42)来调用MyModule对象的方法abs。用42.toString来调用对象42的toString方法。对象内部的成员彼此引用时是无限制的（unqualified），即无需加前缀的，但如果需要的话，他们使用一种特殊m封闭名字"this"来只带对象自身。

值得注意的是，即使是2 + 1这样的表达式也只是调用对象的一个成员。在这种情况下，调用的是对象2的+方法。这是真的只是2.+(1)的一个语法糖而已。当我们调用只接收一个参数的方法时，我们一般省略点和圆括号。例如调用myModule.abs(42)我们可以写成 myModule abs 42，得到同样的结果。

我们可以把对象的成员导入到当前域中，它允许我们不加前缀来调用：

	scala> import MyModule.abs
	import MyModule.abs

	scala> abs(-42)
	res0: 42


我们可以把所有对象所有的（非私有）成员使用下划线语法全部导入：import  MyModule._

>工具栏：包
>在Scala中，就有一种语言构造叫*包*（package），它是一种没有对象的命名空间。包和模块之间的区别是，一个包中不能含有val或def的成员，而且不能像对象一样被传来传去。
>例如，我们可以在Scala的源文件中声明一个包：

	package mypackage
	
	object MyModule {
	  ...
	}

>之后我们可以引用mypackage.MyModule作为一个有限制的名字，或者我们可以import mypackage._ 这样就可以无限制的引用myModule了。然而，我们不能用f(mypackage)这样的语法，把包当做参数传给函数f，因为包不是在Scala中一等公民。

2.5函数对象：把函数作为参数传给函数
---

在Scala中，函数也是对象。它们可以像其他值一样传递、赋值给变量，在数据结构中存储，等等。当编写纯函数程序时，我们很自然的想接收函数作为其他函数的参数。我们来看一些很简单的例子来说明这个思想。在本章中，我们将看到这种能力是多么有用，以及它如何渗透我们的编程风格中去的。但我们首先假设我们想让我们的程序打印出一个数字的绝对值和另一个数的阶乘。下面是这样一个程序的运行结果：

	
	The absolute value of -42 is 42
	The factorial of 7 is 5040

首先，我们来写一个阶乘，这正好是我们第一个不使用可变变量来写一个循环的例子[^footnote2]：

	def factorial(n: Int): Int = { //1
	  def go(n: Int, acc: Int): Int = //2
	    if (n <= 0) acc
	    else go(n-1, n*acc)
	  go(n, 1) 
	}

 1. Int是Scala中有个基本类型，代表32位整数
 2. 这是一个内部或本地方法

[^footnote2]:我们也可以用一个普通的While循环和可变变量来写。看一下这一章的代码示例。


我们在Scala编写循环的方法是用一个递归函数，按惯例，通常被称为go（或是loop），我们通常会定义局部函数（不像Java，Scala中我们可以在任何一个代码块中定义函数，包括在另一个函数体内定义）。go接收的参数是循环的状态（在本例中，其余的值n，和目前的积累因子，acc）。想要前进到下一次迭代，我们只是使用新的循环状态来调用递归函数（在这里，go(n-1，n*acc)），想要退出循环，我们就不再调用递归，而是返回一个值（这里，当n <= 0时我们返回acc的值）。Scala检测这种自递归函数会把它编译成和While循环同样的字节码，这种递归调用出现在函数尾部的位置。看看这个技术细节的工具栏吧，不过基本的思想是，当递归调用后不再做其他额外的事情时，会进行这种优化（称为尾调用优化）[^footnote3]。

[^footnote3]: 这种尾调用优化（TCO）实际上名字取得并不合适。“优化”通常意味着一些不必要的性能改善，但当我们使用尾调用写循环，我们通常依赖于他们被编译为迭代循环，这样不会为每一次迭代消耗调用堆的帧（这会在输入很大时导致StackOverflowError）。

>工具栏：Scala中的尾部调用
>如果调用方除了返回递归调用之外，没有做其他任何事情，则称之为“尾位置”（tail position）。例如，递归调用go(n-1, n*acc)就处在尾位置，因为调用方仅仅返回该递归调用的值。如果，相反，我们返回1 + go(n-1, n*acc)，go函数的调用就不再处于尾位置，因为调用方在go返回它的结果之后仍然有工作要做（即，+1）。同理，如f(go(n-1, n*acc))，f是另一个方法，go的递归调用仍然不处于尾位置。如果所有的递归调用的函数都处于尾位置，Scala会把递归调用编译成迭代循环，这样不会为每一次迭代时消耗调用堆的帧。如果我们期望"尾递归优化"发生在我们写的递归函数上，我们可以使用一个标注（[更多信息可以来这里查看](http://stackoverflow.com/questions/3114142/what-is-the-scala-annotation-to-ensure-a-tail-recursive-function-is-optimized)）来告诉Scala编译器这个预期（关于这方面的更多信息），所以如果这个递归函数确实不能被优化，Scala编译器会返回给我们一个编译错误。这里的语法是这样的：
	
	def factorial(n: Int): Int = {
	  @annotation.tailrec
	  def go(n: Int, acc: Int): Int =
		if (n <= 0) acc
	    else go(n-1, n*acc)
	  go(n, 1)
	}


>我们不会花很多笔墨在本书中介绍标注，不过我们会大量的使用@annotation.tailrec。


习题1（可选）：写一个函数来得到第n个斐波那契数。前两个Fibonacci数分别为0和1，下一个数字是前两个数字相加。你的函数需要使用尾递归[^footnote4]。

￼	 def fib(n: Int): Int

现在我们有了阶乘函数（factorial）,现在让我们在之前的程序上接着进行修改：

[^footnote4]:注意，求第n个斐波那契数有一种[闭式解](https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression)。使用这种解法可算是作弊；这里是让你练习用尾递归来写循环的。

formatAbs和formatFactorial这两个函数几乎是完全相同的。我们也可以把这两个函数抽象成一个函数：formatResult，它接收另一个函数作为参数：

	def formatResult(name: String, n: Int, f: Int => Int) = {
	  val msg = "The %s of %d is %d."
	  msg.format(n, f(n))
	}
	
	def main(args: Array[String]): Unit = {
	  println(formatResult("absolute value", -42, abs))
	  println(formatResult("factorial", 7, factorial))
	}

这里有一些新东西。首先，我们formatResult函数接收多个参数。一个函数如果有多个参数，我们用逗号分隔每个参数。其次，我们的formatResult函数现在需要另一个函数，我们称之为f（这是FP中常见的命名约定，详见工具栏）。一个函数作为另一函数的参数被称为*高阶函数*（higher-order function，HOF）。像其他参数一样，我们给出了一个类型：int => int，这表明f接收一个Int返回也是Int（如果函数的类型是接收一个Int和String并返回一个Int会写成(int, string) => Int）。

接着，注意我们调用f使用同样的语法，如同调用abs(x)或factorial(n)。最后，注意，我们可以把函数abs和formatResult的引用传给函数formatResult。abs接收一个Int返回Int，与f要求的类型 int => int匹配。同样，factorial接收一个Int返回Int，也与f要求的类型 int => int匹配。

>工具栏：FP中的变量命名规则
>HOF接收的函数参数遵从一个共同的约定，使用f，g，h作为参数名。在FP中，我们倾向于使用一个字母或非常短的变量名，尤其所有信息都已经可以由参数的类型表达清楚的时候。因为FP中的函数通常都很短小，许多函数式程序员觉得这会使代码更易于阅读，因为它使代码的结构更明了。我们将在这本书继续介绍类似的约定。

这个例子可能不是很令人兴奋，但同样的原则适用于更大的例子，等我们遇到重复代码时，我们可以用作为一等公民的函数来重构。在这本书中，我们会看到更多这样的例子。

2.5.1匿名函数
---

在函数式编程中函数会经常被传来传去，因此会有一种轻量级的方法来声明一个函数：本地的，匿名的函数。Scala提供了相应的语法来声明这种没有名字或称之为*匿名函数*。（通常也被称为字面函数，lambda函数，Lambda表达式，或是lambda。[^footnote5]）

[^footnote5]:lambda这个名字来源于[lambda演算](http://en.wikipedia.org/wiki/Lambda_calculus)，计算理论中的又一个理论基础


我们来看一些匿名函数的例子：

	def main(args: Array[String]): Unit = {
	  println(formatResult("absolute value", -42, abs))
	  println(formatResult("factorial", 7, factorial))
	  println(formatResult("increment", 7, (x: Int) => x + 1))
	  println(formatResult("increment2", 7, (x) => x + 1))
	  println(formatResult("increment3", 7, x => x + 1))
	  println(formatResult("increment4", 7, _ + 1))
	  println(formatResult("increment5", 7, x => { val r = x + 1; r }))
	}


	The absolute value of -42 is 42
	The factorial of 7 is 5040
	The increment of 7 is 8
	The increment2 of 7 is 8
	The increment3 of 7 is 8
	The increment4 of 7 is 8
	The increment5 of 7 is 8

在这段代码中，(x:Int) => x + 1，(x) => x + 1，x => x + 1 ，和_ + 1都是增量方法的不同写法，它的类型是Int => Int。这个符号，lambda表达式的左端为((x:Int)，(x)，x）和右端（x + 1，{val result = x + 1;result}），用箭分离，=>。左端按顺序声明了参数（(x, y) => x + y是有两个参数的匿名函数的例子），右端，是函数体，表示函数会返回什么。函数体当然可以推倒出参数[^footnote6]。

	￼
