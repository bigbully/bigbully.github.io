---
layout: post
title: Future
description: 
category: scala
---

Future
=====

Akka中两个Actor请求与响应：


	case class Request(str:String)
	case class Response(str:String)
	
	class BadIdea extends Actor {

	  import context._

	  var resActor = system.deadLetters

	  @throws[Exception](classOf[Exception])
	  override def preStart(): Unit = {
	    resActor = actorOf(Props[ResActor], "resActor")
	    resActor ! Request("how are you")
	  }


	  override def receive: Actor.Receive = {
	    case Response(res) => println(res)
	  }

	}
	
	class ResActor extends Actor {
	  override def receive: Actor.Receive = {
	    case Request(str) if str == "how are you" => {
	      sender() ! Response("fine, thank you")
	    }
	  }
	}	

如果这么使用会遇到两个问题：

 1. 无法处理超时
 2. 无法关联上下文

使用Future可以解决这个问题：

	import scala.concurrent.ExecutionContext.Implicits.global //引入测试用的全局线程池
	
	class FutureIdea extends Actor {

	  //import context._ //或引入context内部的使用的线程池

	  var resActor = context.system.deadLetters
	  implicit val timeout = Timeout(2 seconds)

	  @throws[Exception](classOf[Exception])
	  override def preStart(): Unit = {
	    resActor = context.actorOf(Props[ResActor], "resActor")
	    val f: Future[String] = (resActor ? Request("how are you")).mapTo[String]
	    f.onComplete {
	      case Success(res) => println(res)
	      case Failure(e) => e.printStackTrace()
	    }
	  }

	  override def receive: Receive = {
	    case _ =>
	  }
	}
	
	class ResActor extends Actor {
	  override def receive: Actor.Receive = {
	    case Request(str) if str == "how are you" => {
	      sender() ! "fine, thank you"
	    }
	  }
	}	

scala中的Future是**不可变的**，对会在将来某一时刻得到结果的抽象。Future可以承载一个结果或是异常：

	val f1: Future[String] = Future {
	  "how are you"
	}
  
	val f2: Future[Int] = Future {
	  1 / 0
	}

虽然同样是使用线程池进行异步化，但在使用scala的Future时你不需要去关注线程池。

