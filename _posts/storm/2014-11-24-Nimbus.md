---
layout: post
title: Nimbus
description: 
category: storm
---

Nimbus的核心代码在backtype.storm.daemon.nimbus.clj中

main方法如下：

	(defn -main []
	  (-launch (standalone-nimbus)))

-launch方法如下，接收nimbus参数，和storm相关配置一起作为launch-server!的函数参数调用：

	(defn -launch [nimbus]
	  (launch-server! (read-storm-config) nimbus))

在config.clj中实现了read-storm-config函数，他调用java的Utils.readStormConfig静态方法从配置文件中读出配置，使用clojurify-structure转化成clojure的数据结构(如list, map)，通过validate-configs-with-schemas进行验证后返回conf。

	(defn read-storm-config
	  []
	  (let [conf (clojurify-structure (Utils/readStormConfig))]
    (validate-configs-with-schemas conf)
    conf))

standalone-nimbus方法：

	(defn standalone-nimbus []
	  (reify INimbus
	    (prepare [this conf local-dir]
	      )
	    (allSlotsAvailableForScheduling [this supervisors topologies topologies-missing-assignments]
	      (->> supervisors
	           (mapcat (fn [^SupervisorDetails s]
	                     (for [p (.getMeta s)]
	                       (WorkerSlot. (.getId s) p))))
	           set ))
	    (assignSlots [this topology slots]
	      )
	    (getForcedScheduler [this]
	      nil )
	    (getHostName [this supervisors node-id]
	      (if-let [^SupervisorDetails supervisor (get supervisors node-id)]
	        (.getHost supervisor)))
	    ))

这里定义了一个协议实现standalone-nimbus， 它实现了java接口INimbus，并实现了其中的三个方法：

 1. allSlotsAvailableForScheduling方法会把传入参数的SupervisorDetails集合supervisors，根据其中定义的id和不同的port构造WorkerSlot，合并后转化成set。
 2. getForcedScheduler返回空
 3. getHostName使用if-let函数，在supervisors这个map中查找node-id，如果找到，则赋值到supervisor上，并返回host。如果没有找到，则什么也不做。

当我们获得了INimbus的实现后终于可以进行启动前的最后准备了，来看launch-server!函数：

	(defn launch-server! [conf nimbus]
	  (validate-distributed-mode! conf)
	  (let [service-handler (service-handler conf nimbus)
        options (-> (TNonblockingServerSocket. (int (conf NIMBUS-THRIFT-PORT)))
                    (THsHaServer$Args.)
                    (.workerThreads 64)
                    (.protocolFactory (TBinaryProtocol$Factory. false true (conf NIMBUS-THRIFT-MAX-BUFFER-SIZE)))
                    (.processor (Nimbus$Processor. service-handler))
                    )
       server (THsHaServer. (do (set! (. options maxReadBufferBytes)(conf NIMBUS-THRIFT-MAX-BUFFER-SIZE)) options))]
    (.addShutdownHook (Runtime/getRuntime) (Thread. (fn [] (.shutdown service-handler) (.stop server))))
    (log-message "Starting Nimbus server...")
    (.serve server)))

这个方法依次做了以下几步：

 1. 对conf进行分布式校验，如果conf中配置的是本地模式，则直接异常抛出
 2. 通过service-handle函数创建handler
 3. 通过一个串行的宏创建Thrift的processor
 4. 

LocalCluster
-----------------

当我们在本机测试Topology时会用到：

	LocalCluster cluster = new LocalCluster();
    cluster.submitTopology("test", conf, builder.createTopology());

所以我非常想了解一下submitTopology方法都做了些什么。深入源码后我发现LocalCluster类是用clojure实现的。

LocalCluster类在ns中定义了如下所示的gen-class，他实现了java中的ILocalCluster

	LocalCluster.clj...
	
	(ns backtype.storm.LocalCluster
	  (:use [backtype.storm testing config])
	  (:import [java.util Map])
	  (:gen-class
	    :init init
	    :implements [backtype.storm.ILocalCluster]
	    :constructors {[] [] [java.util.Map] []}
	    :state state))


init方法中提供了两个构造函数：

	LocalCluster.clj...
	
	(defn -init
	  ([]
	   (let [ret (mk-local-storm-cluster
               :daemon-conf
               {TOPOLOGY-ENABLE-MESSAGE-TIMEOUTS true})]
     [[] ret]))
	  ([^Map stateMap]
	   [[] stateMap]))

其中无参的构造函数会调用mk-local-storm-cluster方法返回带着配置信息的map，除此之外还提供java.util.Map类型的构造函数，map会直接设置到state属性中。

做完上述铺垫后，终于可以看看submitTopology的实现了。

	LocalCluster.clj...

	(defn -submitTopology
	  [this name conf topology]
	  (submit-local-topology
	    (:nimbus (. this state)) name conf topology))

submitTopology方法接收三个参数，name、conf自不必多说，topology是我们通过TopologyBuilder构建的StormTopology。接下来会调用submit-local-topology方法，并把this.state中的nimbus对应的配置和name, conf, topology作为实参。

以为submit-local-topology和其他local方法实际上都是本地测试用的，所以被放在testing.clj中，代码如下：

	testing.clj...

	(defn submit-local-topology
	  [nimbus storm-name conf topology]
	  (when-not (Utils/isValidConf conf)
	    (throw (IllegalArgumentException. "Topology conf is not json-serializable")))
	  (.submitTopology nimbus storm-name nil (to-json conf) topology))

这个方法校验了conf，如果校验失败，抛出IllegalArgumentException异常，如果正常，则把conf转成json之后调用java类Nimbus中的Thrift服务submitTopology提交Topology。











