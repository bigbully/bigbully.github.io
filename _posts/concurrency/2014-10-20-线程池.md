---
layout: post
title: 我所知道的线程池
description: 线程池学习笔记
category: concurrency
---

我所知道的线程池
===============

线程池其实或多或少都用过，不过这是我第一次阅读它的源码，包括源码附带的非常详尽的注释。发现我之前对于线程池的理解还是很浅薄的。

其实从ThreadPoolExecutor.java顶部200多行的注释就能一定程度上了解线程池的用法了。

首先看一下线程池的初始化方式：

	public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,long keepAliveTime,                   TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler) 

>**参数说明**
> - corePoolSize 核心线程数：提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。
> - maximumPoolSize 最大线程数：线程池允许存活的线程数的最大值。核心线程数不能超过最大线程数。
> - keepAliveTime 非核心线程数的存活时间：如果核心线程数小于最大线程数，那么核心线程之外的那些线程当存活超过keepAliveTime，就会被终止。
> - unit 存活时间的单位
> - workQueue 线程池使用的队列
> - threadFactory 线程工厂
> - handler 当线程池拒绝提交新的任务时使用的策略。

默认构造方法的参数着实不少，一开始我根本无法理解为什么需要这么多初始化参数，不过在源码的注释中，针对不同的场景如何设置线程池参数的示例。

首先需要了解的是corePoolSize，maximumPoolSize，workQueue，handler四者之间的关系。

![image](http://bigbully.github.io/images/线程池.png)

依照这个关系图，在源码注释中给出了3种推荐策略：

>**推荐策略**

> - 直接的任务传递：最大线程数设为Integer.MAX_VALUE,workQueue使用SynchronousQueue，因为SynchronousQueue自身特性不保留任何元素，所以当核心线程都在使用时，任何提交的任务都会创建新的非核心线程。这种方式任务处理的吞吐量最大，不过会消耗更多地资源。
> - 无界队列：可以使用LinkedBlockingQueue这种无界队列，这时最大线程数这个参数不再有意义。当任务提交频率较平缓时，且所有提交的任务之间都彼此独立时使用这种策略。不过需要担心一下内存溢出的问题。
> - 有界队列：例如使用ArrayBlockingQueue，会根据队列的size和最大线程数来调整线程池对资源的使用和吞吐量的高低。


接下来从源码层面来研究一下线程池的实现。

![image](http://bigbully.github.io/images/线程池2.png)

ThreadPoolExecutor自身的层级结构如图所示。最上层的执行器Executor接口本身只具备void execute(Runnable command)的能力，而ExecutorService作为一个service又必须具备提交任务、正常关闭等职能，在AbstractExecutorService实现了一些公共方法。ThreadPoolExecutor作为线程池的基础实现，其下还有若干具备特殊功能的线程池继承自ThreadPoolExecutor。

不过这篇笔记只研究ThreadPoolExecutor的实现，其他不同类别的特殊线程池的学习放在之后进行。

ThreadPoolExecutor中也涉及到一些和AbstractQueuedSynchronizer相关的操作，AbstractQueuedSynchronizer及其各种实现类可以我在[并发的灵魂](http://bigbully.github.io/AbstractQueuedSynchronizer/)中有详尽的解析，在此只简单描述它的功能。

作为一个Executor的实现类，自然要从execute方法说起：

	public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
     
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {//如果工作线程数小于核心线程数
            if (addWorker(command, true))//创建worker，第二个参数为true表示创建核心线程
                return;//创建成功则返回
            c = ctl.get();//创建失败获取保存的ctl
        }
        if (isRunning(c) && workQueue.offer(command)) {//判断ctl中的状态，如果线程池处于RUNNING状态，则把任务放入队列中
            int recheck = ctl.get();//重新确认状态
            if (! isRunning(recheck) && remove(command))//如果线程池已关闭，则移除任务
                reject(command);//移除成功调用RejectedExecutionHandler
            else if (workerCountOf(recheck) == 0)//如果remove失败
                addWorker(null, false);//自旋检查是否Q中所有任务都已经处理完成
        }//如果线程池已经关闭或队列已满
        else if (!addWorker(command, false))//尝试创建worker,并使用非核心线程
            reject(command);//创建失败调用RejectedExecutionHandler
    }

这方法就涉及到ctl属性：

	private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

用一个支持并发的原子Int类型来保存两个属性：工作线程数和当前线程池状态。由于两个属性共享一个原子Int类型，所以线程池共支持(2^29)-1，大于5亿个线程。线程池的状态共分为一下五种：

 - RUNNING
 - SHUTDOWN 这个状态不再接收新的task，不过当前正在处理队列中的task
 - STOP 这个状态不再接受新的task，并不在处理队列中的task
 - TIDYING 这个状态所有的task都已经执行完毕，工作线程数降为0，不过正在执行terminated()方法
 - TERMINATED 这个状态表示terminated()方法已经执行完毕

以上五种状态从上至下一次发生状态改变，唯一的特例在于如果当前没有task可以处理，那么RUNNING状态会直接转变为STOP状态。

这个int类型共32位，保留最左3位用来保存5个状态值，右边29位保存工作线程数，所以以下几个方法(rs表示runState，wc表示workerCount)也就非常好理解了。

	
	private static final int COUNT_BITS = Integer.SIZE - 3;
    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

    // runState is stored in the high-order bits
    private static final int RUNNING    = -1 << COUNT_BITS;
    private static final int SHUTDOWN   =  0 << COUNT_BITS;
    private static final int STOP       =  1 << COUNT_BITS;
    private static final int TIDYING    =  2 << COUNT_BITS;
    private static final int TERMINATED =  3 << COUNT_BITS;

    // Packing and unpacking ctl
    private static int runStateOf(int c)     { return c & ~CAPACITY; }
    private static int workerCountOf(int c)  { return c & CAPACITY; }
    private static int ctlOf(int rs, int wc) { return rs | wc; }

回到execute方法的源码中，从源码可以看出之前流程图表示的逻辑。详细流程这次在源码中以注释方式标明。

再来详细看一下addWorker方法，终于有机会在jdk源代码中见识一下java中的“goto”了！：

	//方法接收两个参数，第一个参数是首个任务，可以为空，第二个参数表示是否创建在核心线程中
	private boolean addWorker(Runnable firstTask, boolean core) {
		//以下是两层自旋，为了能从内层自旋直接跳到外层自旋，所以在这里设置retry标示
        retry:
        for (;;) {
            int c = ctl.get();//首先获得ctl的引用
            int rs = runStateOf(c);//计算出当前线程池的状态

            // Check if queue empty only if necessary.
            //以下需要判断如果线程池处于非开启状态，并且队列仍然未清空时会进行自旋
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                return false;//如果线程池关闭后队列清空，则成功返回

			//这里是内层自旋
            for (;;) {
                int wc = workerCountOf(c);//首先得到当前worker的数量，也就是池中线程数量
                if (wc >= CAPACITY ||
                    wc >= (core ? corePoolSize : maximumPoolSize))//如果超标
                    return false;//直接返回失败
                if (compareAndIncrementWorkerCount(c))//没超标则cas方式增加work数
                    break retry;//成功后直接退出外层自旋
                c = ctl.get();  // Re-read ctl//如果失败的话需要reload ctl
                if (runStateOf(c) != rs)//如果当前状态已经改变，则重新自旋
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
                //如果状态没改变的话，也许有其他任务同时提交，内层自旋
            }
        }

        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            final ReentrantLock mainLock = this.mainLock;//在增减Worker的时候使用锁而不使用并发容器官方的解释时，当线程池shutdown的时候为了避免线程中断的高峰，加锁后可以变为串行执行
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int c = ctl.get();
                    int rs = runStateOf(c);//double check

                    if (rs < SHUTDOWN || //如果线程池正在运行
                        (rs == SHUTDOWN && firstTask == null)) { //或是shutdown后调用firstTask为null的时候
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        int s = workers.size();
                        if (s > largestPoolSize)//largestPoolSize用来表示线程池中曾经到达过的最大线程数
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    t.start();//线程启动在这里
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)//只有在线程池处于非运行状态下才会添加失败
                addWorkerFailed(w);//这时除了会从works中移除work之外，还会触发tryTerminate操作，tryTerminate会在任何发现当前线程池已经关闭的时候触发，不只在执行shutdown操作的时候触发。
        }
        return workerStarted;
    }


addWorker方法就是这样。如果用过线程池就会发现，提交任务还有一种带返回值的方式，也就是submit，它是怎么做的呢？答案在AbstractExecutorService这个基类中。

	public Future<?> submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<Void> ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }

   
    public <T> Future<T> submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }

   
    public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }

提供了三种submit方式，其实都是构造成FutureTask，因为FutureTask实现了Runnable接口，可以直接调用上文提到的execute方法执行，最终把FutureTask对象返回给用户即可。

线程池还提供了invokeAll和invokeAny方法，用来批量提交任务，两个方法都是阻塞执行的，区别在于，invokeAll方法只有当所有任务都执行完之后才返回结果集，而invokeAny方法只要有一个任务执行完成了，就把结果返回，并取消其他未执行完成的任务。invokeAll和invokeAny都提供阻塞和带超时时间的方法。如下所示：

	 <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException;

	<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;

	<T> T invokeAny(Collection<? extends Callable<T>> tasks)
        throws InterruptedException, ExecutionException;

	<T> T invokeAny(Collection<? extends Callable<T>> tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;

下面来分别看看这两种方法是如何实现的。invokeAll方法：

	public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException {
        if (tasks == null)
            throw new NullPointerException();
        List<Future<T>> futures = new ArrayList<Future<T>>(tasks.size());
        boolean done = false;
        try {
            for (Callable<T> t : tasks) {
                RunnableFuture<T> f = newTaskFor(t);
                futures.add(f);
                execute(f);
            }
            for (Future<T> f : futures) {
                if (!f.isDone()) {
                    try {
                        f.get();
                    } catch (CancellationException ignore) {
                    } catch (ExecutionException ignore) {
                    }
                }
            }
            done = true;
            return futures;
        } finally {
            if (!done)
                for (Future<T> f : futures)
                    f.cancel(true);
        }
    }

这方法几乎不用解释，只是按提交任务的顺序，循环遍历任务列表等待任务结果，这过程中不响应任何异常，除非任务被取消，当有任务被取消时所有任务都依次被取消，抛出InterruptedException异常。

带超时时间的invokeAll方法其实也很简单，只不过在每次提交任务判断是否已经超时，获得futureTask结果时使用 f.get(nanos, TimeUnit.NANOSECONDS)，当出现超时异常时取消所有任务，并返回结果集。

invokeAny是否包含超时时间的两个方法实际上都调用的时下面这个doInvokeAny方法，这个方法我以注释的方式加以分析:

	//第二个参数用来标识是否有超时时间
	private <T> T doInvokeAny(Collection<? extends Callable<T>> tasks,
                            boolean timed, long nanos)
        throws InterruptedException, ExecutionException, TimeoutException {
        if (tasks == null)
            throw new NullPointerException();
        int ntasks = tasks.size();//这里会记录待提交任务数
        if (ntasks == 0)
            throw new IllegalArgumentException();
        List<Future<T>> futures= new ArrayList<Future<T>>(ntasks);//创建一个用来记录任务结果的集合
        //这里构造了一个线程池的包装类，实现很简单，当任务执行完成后，会放入一个FIFO的队列，所以这个队里是以任务的完成先后来排序的，这一点非常重要
        ExecutorCompletionService<T> ecs =
            new ExecutorCompletionService<T>(this);

        try {
	        //这里记录任务运行失败的最后一次异常信息，如果所有任务都失败了，则会抛出这个异常。
            ExecutionException ee = null;
            long lastTime = timed ? System.nanoTime() : 0;
            Iterator<? extends Callable<T>> it = tasks.iterator();//获得所有任务的迭代器
            
            futures.add(ecs.submit(it.next()));//执行第一个任务并加入结果集合
            --ntasks;//待提交任务会减少
            int active = 1;//正在进行的任务会增加

            for (;;) {//接下来进入自旋
                Future<T> f = ecs.poll();//这里会返回最先完成的任务
                if (f == null) {//如果为空
                    if (ntasks > 0) {//而且还有任务可以提交，则进行任务的提交
                        --ntasks;
                        futures.add(ecs.submit(it.next()));
                        ++active;
                    }
                    else if (active == 0)//如果没有任务可以提交，而且所有提交的任务都已经完成，则跳出自旋
                        break;
                    else if (timed) {//如果没有任务可以提交，而且需要考虑超时时间，则在一定时间内等待有任务完成
                        f = ecs.poll(nanos, TimeUnit.NANOSECONDS);
                        if (f == null)//超时则抛出超时异常
                            throw new TimeoutException();
                        long now = System.nanoTime();
                        nanos -= now - lastTime;
                        lastTime = now;//获得任务后进行超时时间的计算
                    }
                    else//如果不需要考虑超时时间，则阻塞的等待第一个任务完成
                        f = ecs.take();
                }
                
                if (f != null) {//当有任务完成时
                    --active;//正在进行的任务数会减少
                    try {
                        return f.get();//如果能顺利获得结果，则直接返回，如果出现任何异常，则进入自旋，尝试等待下一个任务完成
                    } catch (ExecutionException eex) {
                        ee = eex;
                    } catch (RuntimeException rex) {
                        ee = new ExecutionException(rex);
                    }
                }
            }
			//当所有任务都执行完成，且没有任何任务成功时，会抛出异常
            if (ee == null)
                ee = new ExecutionException();
            throw ee;

        } finally {//如果某一个任务成功执行完毕，则取消所有任务
            for (Future<T> f : futures)
                f.cancel(true);
        }
    }

以上就是线程池的批量执行方法的分析。